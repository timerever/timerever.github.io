{
    "version": "https://jsonfeed.org/version/1",
    "title": "A Blog • All posts by \"hibernate\" tag",
    "description": "Just another blog.",
    "home_page_url": "https://blog.timerever.tk",
    "items": [
        {
            "id": "https://blog.timerever.tk/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/",
            "url": "https://blog.timerever.tk/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/",
            "title": "【翻译】Hibernate 软删除：你可能忽略掉的一些东西",
            "date_published": "2022-01-07T11:34:47.000Z",
            "content_html": "<img src=\"/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/soft-deletion-in-hibernate-things-you-may-miss-1.png\" class=\"\">\n<p>我们在设计生产系统的时候，无论是为了方便恢复、便于查找问题还是审计等，总是绕不开软删除这个话题。国内互联网公司大部分均使用 MyBatis 作为 ORM 框架，所以大部分的资料也都是 MyBatis 的各种软删除实现，用起来也都没什么问题。但是手里项目使用的是 Hibernate，虽然 Hibernate 也可以找到很多软删除的方案，当初最开始参考的也是原文列出的第一个 Baeldung 网站的方案，但是由于 Hibernate 大部分时候都是直接对实体进行操作，所以软删除用起来会遇到很多的问题。比如自己就遇到了软删除 + 二级缓存冲突的问题，先抛开这个不谈，毕竟在权衡之下直接关闭二级缓存就解决了问题，在基本使用时软删除也不可避免地会遇到各种问题。正好偶然看到了 JPA Buddy 上一篇文章在说这个问题，索性简单翻译下，希望大家在设计软删除方案的时候能够进行充分的考虑。</p>\n<p>原文：<a href=\"https://www.jpa-buddy.com/blog/soft-deletion-in-hibernate-things-you-may-miss/\">Soft Deletion in Hibernate: Things You May Miss</a></p>\n<span id=\"more\"></span>\n<hr />\n<p>软删除是一种广泛使用的模式，简单来说就是：你仅仅将实体标记为删除状态并通过在 SELECT 查询中过滤他们而不是物理删除这些实体。使用软删除有很多常见的原因：审计、可恢复性、或者可以很方便地在将数据伪造成删除状态的同时保持着对这些“已删除”记录的引用。</p>\n<p>在这篇文章中我们将关注一些大部分讲述软删除方案的文章所未提到的细节。</p>\n<h4 id=\"sqldelete-where\"><a class=\"markdownIt-Anchor\" href=\"#sqldelete-where\"></a> @SQLDelete + @Where</h4>\n<p>如果你以“soft deletion hibernate”为关键词在谷歌上进行搜索的话，你很可能找到 <a href=\"https://www.baeldung.com/spring-jpa-soft-delete\">Eugen Paraschiv</a>、<a href=\"https://vladmihalcea.com/the-best-way-to-soft-delete-with-hibernate/\">Vlad Mihalcea</a> 或是 <a href=\"https://thorben-janssen.com/implement-soft-delete-hibernate/\">Thorben Janssen</a> 写的教程。他们都建议使用 Hibernate 的 <code>@SQLDelete</code> 和 <code>@Where</code> 注解来让程序自动设置删除标识并可以在查询时自动过滤这些数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = &quot;article&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SQLDelete(sql = &quot;update article set deleted=true where id=?&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Where(clause = &quot;deleted = false&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Article</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"meta\">@Id</span></span><br><span class=\"line\">   <span class=\"meta\">@GeneratedValue(strategy = GenerationType.SEQUENCE)</span></span><br><span class=\"line\">   <span class=\"meta\">@Column(name = &quot;id&quot;, nullable = false)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Column(name = &quot;deleted&quot;, nullable = false)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> Boolean deleted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// other properties, getters and setters omitted</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@SQLDelete</code> 注解会在 Hibernate 管理的对象被删除时执行我们设定好的原生 SQL 语句。<code>@Where</code> 注解通过将自身的查询条件自动追加到 SELECT 查询语句中来帮你自动过滤掉这些被标记为删除的数据。</p>\n<p>这个方法看上去是一剂良药，但是里面有坑。普通查询肯定可以正常工作，但是如果是关联查询呢？</p>\n<h4 id=\"关联查询所遇到的问题\"><a class=\"markdownIt-Anchor\" href=\"#关联查询所遇到的问题\"></a> 关联查询所遇到的问题</h4>\n<p>让我们仔细思考一下，假设你拥有一个实体，里面可能关联了另一个实体的集合，或者仅仅是另一个实体对象，但相同的是他们均被软删除。当你获取到这个实体对象时，你期望发生什么？实际上，这里没有几个选项可供选择：被删除的记录呈现或者不呈现在查询结果中，而不同的选择取决于不同的场景用例。比如，我们在商城购物车中有很多的商品，当一件商品被删除时我们期望其从购物车中消失对吧？但是被删除的商品仍应该出现在历史账单中，这难道不矛盾嘛？</p>\n<p>让我们来看一下 <code>@SQLDelete</code> 和 <code>@Where</code> 注解在不同类型的关联关系、FetchType 和不同的查询 API 中是怎样工作的。下面是我们将要在后续实验中使用的 ER 图：</p>\n<img src=\"/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/soft-deletion-in-hibernate-things-you-may-miss-2.png\" class=\"\" title=\"ER 图\">\n<p>Article 和 Author 拥有多对多关系，和 Comment 有着一对多关系，以及和 ArticleDetails 有着一对一的关系。那么问题来了，他们中的某一个在被其他实体引用时被软删除会发生什么？</p>\n<h4 id=\"onetomany-manytomany\"><a class=\"markdownIt-Anchor\" href=\"#onetomany-manytomany\"></a> OneToMany &amp; ManyToMany</h4>\n<p>Hibernate 会自动在所有对多关系中过滤掉被删除的实体。如果你在删除一个 Author 之前和之后分别运行下面的代码，打印出的 Author 的名字数量会发生变化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Article&gt; articleOptional = articleRepository.findById(<span class=\"number\">4L</span>);</span><br><span class=\"line\">articleOptional.ifPresent(article -&gt; &#123;</span><br><span class=\"line\">   article.getAuthors()</span><br><span class=\"line\">           .forEach(author -&gt; logger.info(author.getName()));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>好消息是，无论 FetchType 的值是什么或者用哪种查询方式（比如 entityManager、Criteria API、Spring Data JPA 等），上述结果都成立。</p>\n<h4 id=\"懒加载下的-manytoone-onetoone\"><a class=\"markdownIt-Anchor\" href=\"#懒加载下的-manytoone-onetoone\"></a> 懒加载下的 ManyToOne &amp; OneToOne</h4>\n<p>让我们试着想象一下我们软删除了一篇文章，但我们不希望删除这篇文章下面的评论，因为这样在恢复文章时评论也会自动恢复。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = &quot;comment&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comment</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"meta\">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class=\"line\">   <span class=\"meta\">@JoinColumn(name = &quot;article_id&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> Article article;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，让我们尝试获取一条对应文章被删除的评论：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Comment&gt; comment = commentRepository.findById(id);</span><br><span class=\"line\">comment.ifPresent(com -&gt; logger.info(com.getArticle().getText()));</span><br></pre></td></tr></table></figure>\n<p>如果你在第一行打一个断点，你可以看到 article 属性的值是 Hibernate Proxy 对象。</p>\n<img src=\"/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/soft-deletion-in-hibernate-things-you-may-miss-3.png\" class=\"\" title=\"debug\">\n<p>这很容易理解，因为 Hibernate 并不能提前知道这个实体是否已经被删除。但是当我们执行 <code>com.getArticle().getText()</code> 方法时，却抛出了 EntityNotFoundException 异常，这是你所期望的吗？</p>\n<h4 id=\"提前加载下的-manytoone-onetoone\"><a class=\"markdownIt-Anchor\" href=\"#提前加载下的-manytoone-onetoone\"></a> 提前加载下的 ManyToOne &amp; OneToOne</h4>\n<p>让我们将 FetchType 的值改为 EAGER 后再次重复相同的实验。现在我们在程序不使用代理的情况下获取到了关联的 article 对象，虽然 Hibernate 知道 article 已经被删除了。让我们进行同样的测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Comment&gt; comment = commentRepository.findById(id);</span><br><span class=\"line\">comment.ifPresent(com -&gt; logger.info(com.getArticle().getText()));</span><br></pre></td></tr></table></figure>\n<p>被关联查询且被软删除的 article 对象在没有报任何异常的情况下被加载了，其软删除标志为也依然为 <code>true</code>：</p>\n<img src=\"/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/soft-deletion-in-hibernate-things-you-may-miss-4.png\" class=\"\" title=\"debug\">\n<p>这种不一致的行为很容易被解释，提前加载让 Hibernate 查询时 join 了 <code>article</code> 表。Hibernate 面临着立即抛出 EntityNotFoundException 异常还是正常加载的抉择，但因为 article 已经被加载了，<code>@Where</code> 注解失去了它的作用，所以 Hibernate 只是简单地为对象赋了值。</p>\n<p>现在让我们批量查询 comments：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterable&lt;Comment&gt; comments = commentRepository.findAll();</span><br></pre></td></tr></table></figure>\n<p>现在我们又遇到了 EntityNotFoundException 异常！出现异常是因为 <code>findAll</code> 方法分离查询被关联的 Article 对象，详情可以参考 <a href=\"https://stackoverflow.com/questions/49192255/spring-data-findall-does-not-fetch-eagerly/49193254\">Spring data findAll() does not fetch eagerly</a>。</p>\n<p>任何时候被软删除的对象在被使用分离查询时都会导致上面的异常，因为 Hibernate 在生成分离查询时应用了 <code>@Where</code> 所定义的条件，所以很显然 Hibernate 并不能查询到被软删除的实体。所以很显然，这种查询并不能查到 Hibernate 所期望的结果，所以在这种情况下导致了 EntityNotFoundException 异常。</p>\n<p>所以更有趣的是你需要进行很多实验来认识到 Hibernate 在使用不同的 API 时是怎样获取数据的。首先，无论是对多还是对一的实体，在使用 DSL 查询时你均会遇到同样的异常。与此同时，criteria API 会在提前加载的一对一关系下返回被删除的实体，但会在提前加载的多对一关系中抛出 EntityNotFoundException 异常。这难道不令人困惑吗？</p>\n<h4 id=\"避免-entitynotfoundexception-异常的解决方式\"><a class=\"markdownIt-Anchor\" href=\"#避免-entitynotfoundexception-异常的解决方式\"></a> 避免 EntityNotFoundException 异常的解决方式</h4>\n<p>这里有一个可以避免 EntityNotFoundException 异常的解决方法。Hibernate <a href=\"https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#associations-not-found\">介绍</a>了 <code>@NotFound</code> 注解，它能够让程序不再抛出异常，而是直接将关联对象的值设置为 <code>null</code>。</p>\n<p>这个解决办法看起来是一个灵丹妙药，但它同时带来了额外的缺点：无论 FetchType 设置为什么，所有的对一关系均会提前加载。</p>\n<img src=\"/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/soft-deletion-in-hibernate-things-you-may-miss-5.png\" class=\"\" title=\"官网介绍\">\n<h4 id=\"约束和索引带来的问题\"><a class=\"markdownIt-Anchor\" href=\"#约束和索引带来的问题\"></a> 约束和索引带来的问题</h4>\n<p>我们知道被软删除的实体和正常的实体均会被唯一约束和索引所限制，因此，常规的索引在这种情况下不再适用。假设一个 Author 实体的 login 字段有唯一约束，在软删除表中已有的记录后，记录仍然存在，所以正常状态的 Author 实体的同样的字段也不能再被设置为被软删除的相同的值。</p>\n<p>如果你正在使用 PostgreSQL，那么你很幸运，因为你可以使用部分索引：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">CREATE UNIQUE INDEX author_login_idx ON <span class=\"title\">author</span> <span class=\"params\">(login)</span> WHERE deleted </span>= <span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>但如果你使用的是 MySQL，那么很不幸，这个问题无解。</p>\n<h4 id=\"结论\"><a class=\"markdownIt-Anchor\" href=\"#结论\"></a> 结论</h4>\n<p>所以你可以看到，软删除是一个很容易被理解但不容易去实现的模式。看上去现在还没有一个完美的解决方案，至少 Hibernate 现阶段还没有提供。</p>\n<p>在一些简单的场景，你确实可以直接采用使用 <code>@SQLDelete</code> + <code>@Where</code> 注解的方式，但在软删除实体出现在一对一或者多对一关联关系的时候，你并不能期望他们行为一致。只是简单地改变 FetchType 的值，或是使用 <code>@EntityGraph</code>，或者将你的查询从 Criteria API 迁移到 DSL 查询，或是其他任何改变都很可能影响查询结果：从被意外抛出异常到意外地成功加载了被删除的实体，或是直接获得了意料之外的 <code>null</code> 值。</p>\n",
            "tags": [
                "Java",
                "Hibernate",
                "Translate"
            ]
        },
        {
            "id": "https://blog.timerever.tk/2021/12/02/hibernate-incorrect-metamodel-with-no-reationship/",
            "url": "https://blog.timerever.tk/2021/12/02/hibernate-incorrect-metamodel-with-no-reationship/",
            "title": "Hibernate 解决 Metamodel 属性类型错误问题",
            "date_published": "2021-12-02T03:41:48.000Z",
            "content_html": "<p>因为项目上使用了 Hibernate Metamodel，而且自定义映射了数据库的 JSON 字段类型，导致生成的 Metamodel 属性类型有误。虽然并没有用映射的这些属性做 <code>CriteriaQuery</code>，所以其实在项目的使用上没有影响，但是启动时还是会报一个 ERROR 日志，所以寻找一个能够根治的解决办法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR org.hibernate.metamodel.internal.MetadataContext [MetadataContext.java:491] - HHH015007: Illegal argument on static metamodel field injection : Foo_#bars; expected type : org.hibernate.metamodel.model.domain.internal.SingularAttributeImpl; encountered type : javax.persistence.metamodel.MapAttribute</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h3 id=\"一-定位问题\"><a class=\"markdownIt-Anchor\" href=\"#一-定位问题\"></a> 一、定位问题</h3>\n<p><strong>首先是背景信息：</strong> 因为前端需要在数据库存储 JSON 字段，而且现在版本的 MySQL 天然支持 JSON ，所以建表时采用了 JSON 作为字段类型。然后在 JPA 实体层面，引入了 <code>hibernate-types</code> 依赖来增加 Hibernate 对 JSON 的支持，字段属性增加了 <code>@Type(type = &quot;json&quot;)</code> 注解，本身定义为了 <code>Map</code> 类型。</p>\n<p>其实在 Hibernate 对 JSON 处理这件事情上，传统方案是通过自定义 <code>Convert</code> 来实现。或者可能不是 JSON Object 而是 JSON Array，但无论是哪种情况，均会遇到同样的问题。</p>\n<p>通过报错信息，对代码进行 DEBUG 后得知，Hibernate 在启动时，会根据实体属性是否存在与其他实体的关系，生成不同的 <code>Attribute</code>。比如 OneToMany 一对多关系就会生成 <code>ListAttribute</code> 或 <code>SetAttribute</code>，没有关系的属性都是 <code>SingularAttribute</code>。而启动时通过反射，会 set Metamodel 的对应属性，我们可以在 target 下面看见，Metamodel 的类型为 <code>MapAttribute</code>，所以我们可以确定，问题就出在了生成 Metamodel 的时候。具体是不是直接拿实体定义的数据类型来生成的我没有去看源码，不过可以肯定的是它在判断类型的时候缺少额外的判断。</p>\n<h3 id=\"二-解决问题\"><a class=\"markdownIt-Anchor\" href=\"#二-解决问题\"></a> 二、解决问题</h3>\n<p>同样作为一个共性问题，在 Goolge 进行搜索后，定位到了一条仍然是 Hibernate 官方 Bug 追踪的链接 <a href=\"https://hibernate.atlassian.net/browse/HHH-12338\">Incorrect metamodel for basic collections</a>。简单的来说，就是当前已经在 5.5.0.Alpha1 的版本中得到了解决，不过如果你认真看了下面整个的 Activity 记录，就会发现仍然是存在一个小插曲。</p>\n<h3 id=\"三-插曲\"><a class=\"markdownIt-Anchor\" href=\"#三-插曲\"></a> 三、插曲</h3>\n<p>这个问题是在 2018 年的 3 月份被提出来的，而 5.5.0.Alpha1 已经是 2021 年 8 月份的事情了，照理说这么一个小问题不会需要三年多的时间来处理，而这个疑问的答案就在下面的讨论之中。</p>\n<p>简单来说，这个问题在当月就被解决掉了，伴随着 5.2.17 的版本发布，这个问题理论上来说就不应该再存在了。然而事与愿违，在 5.2.17 版本发布之后，很快就有人提出了新的问题。在下面的 Comment 中有记录，同时这个人也单独提了一个 issue <a href=\"https://hibernate.atlassian.net/browse/HHH-12581\">NPE for Criteria query containing fetch join as a regression of HHH-12338</a>，即这次的改动造成了 NPE。然后可以看到在另一个维护者与之前 Vlad Mihalcea 的一番讨论之后，他们决定恢复这次的改动。</p>\n<img src=\"/2021/12/02/hibernate-incorrect-metamodel-with-no-reationship/hibernate-incorrect-metamodel-with-no-reationship-1.png\" class=\"\" title=\"revert commit\">\n<p>但是回退了就意味着问题又回来了，上面提到的 Vlad Mihalcea 从红帽离职，不再维护 Hibernate 还弄了一个新的项目就是上面提到的 <code>hibernate-types</code>。所以其他人在遇到相同的问题时，有部分和我们一样是采用的 <code>hibernate-types</code> 方案，自然而然有人把问题又丢给了 Vlad Mihalcea，不过是在 <code>hibernate-types</code> 项目。</p>\n<p>于是 Vlad Mihalcea 在 Github 提了新的 PR，见 <a href=\"https://github.com/hibernate/hibernate-orm/pull/3254\">HHH-12338 - Incorrect metamodel for basic collections</a>。不过很不幸的是，并没有后续。</p>\n<p>直到今年的 7 月，又一位开发者忍无可忍决定解决这个问题，提了新的 PR 出来，见 <a href=\"https://github.com/hibernate/hibernate-orm/pull/4096\">HHH-14724 Test-case for metamodel compile error with converters and validation</a>。这次终于引起了重视，并在一番努力之后，终于得到了合并，问题就此解决。</p>\n<p>题外话，这件事情，是不是跟前阵子遇到的 <a href=\"/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/\">Hibernate 配置自动清除二级缓存之集合缓存</a> 里面的插曲有点像？笑。</p>\n<h3 id=\"四-亲力亲为\"><a class=\"markdownIt-Anchor\" href=\"#四-亲力亲为\"></a> 四、亲力亲为</h3>\n<p>虽说这件事情现在看来终于告一段落了，不过由于时今年 9 月份才最终解决，虽然代码已经被合并到了各个版本的分支中，但 5.4 已经半年没有发过新的版本了。虽说 5.5 和 5.6 的版本已经没问题了，但由于项目框架的问题，并不能直接升级 Hibernate 的版本，而且本来 5.5 的版本就存在很大改动，现有架构并不能保证完全兼容（比如还是上面提到的 <code>hibernate-types</code> 就需要引入另外一个包），所以最后没有办法，只能决定采用重打包的方式自己对源码进行更新。</p>\n<p>剩下的事情就不再赘述了，大概流程就是下载 Hibernate 源码，找到 5.4.32.Final 的 tag，在此基础上手动把修复代码的变更拷贝过来，然后改个版本号，发布到私仓，再更改当前项目依赖的版本号，最后成功解决。</p>\n",
            "tags": [
                "Java",
                "Hibernate"
            ]
        },
        {
            "id": "https://blog.timerever.tk/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/",
            "url": "https://blog.timerever.tk/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/",
            "title": "Hibernate 配置自动清除二级缓存之集合缓存",
            "date_published": "2021-11-26T07:21:10.000Z",
            "content_html": "<p>之前在项目上使用了 Hibernate，并开启了基于 caffeine 的二级缓存。因为 Hibernate 会自动处理缓存，所以一直没怎么关注。直到最近，发现在一种特定的情况下，Hibernate 不会自动清除二级缓存里面的集合缓存。问题最后解决起来其实很简单，增加一个配置项的事。不过问题寻求解决的过程还是蛮繁琐的，并没有人能够直接告诉这个问题的答案，在此记录一下这个问题的排查过程。</p>\n<blockquote>\n<p>太长不看版：Spring Boot 中设置属性 spring.jpa.properties.auto_evict_collection_cache=true 即可解决。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"一-问题出现\"><a class=\"markdownIt-Anchor\" href=\"#一-问题出现\"></a> 一、问题出现</h3>\n<p>假定我这里有两个实体，分别为 <code>Parent</code> 和 <code>Child</code>。然后 Parent 与 Child 之间存在一对多的对应关系，即在 Parent 的实体中，存在一个属性 <code>private Set&lt;Child&gt; children</code>，然后我们开启二级缓存 <code>@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)</code>。在这种情况下，我们先访问 Parent 实体并获取其中的 <code>children</code> 属性，确保其已被缓存。然后我们再单独操作 Child，我们新建一个 Child 对象 <code>Child child = new Child()</code> 并设置其 Parent 的值 <code>child.setParent(parent)</code> 并保存 Child 实体 <code>ChildRepository.save(child)</code>。然后我们回过来获取 Parent，会发现 Parent 的 <code>children</code> 的值仍为原数组对象， 没有我们新增的 <code>child</code> 对象。</p>\n<p>通过在 Google 上进行搜索，发现 stackoverflow 上存在几个类似的问题，再进一步的搜索后，发现在 Hibernate 官方 Bug 追踪网站上有人归纳并提出了这个问题 <a href=\"https://hibernate.atlassian.net/browse/HHH-4910\">automatic L2 collection cache eviction when an element is added/updated/removed</a>，可以看到不只是自己遇到的新增，修改/删除也会有类似的问题。</p>\n<h3 id=\"二-问题解决\"><a class=\"markdownIt-Anchor\" href=\"#二-问题解决\"></a> 二、问题解决</h3>\n<p>在上面链接的内容下方，问题提出者给出了一种 workaround 的方案，提供 <code>@PostPersist</code>、<code>@PostRemove</code> 及 <code>@PreUpdate</code> 的监听，并在监听中自动清理缓存。以及在之前查阅 stackoverflow 时，也有人认为，你需要在操作多方元素的时候，同时操作一方对应的集合，对其进行 add/remove 操作。</p>\n<p>但不管怎么说，这些都是一些 workaround 方案，因为 Hibernate 本身是有能力自动处理这些事情的。话又说回来，既然问题很早就被提出了，比如这个链接中使用的版本是 <code>3.3.1</code>，同时官方也已经记录了这个问题已经在 <code>4.3.0.Beta5</code> 中被修复了，可是为什么我们还是会遇到这个问题？这个答案其实在下面的评论中。</p>\n<img src=\"/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/hibernate-automatic-2nd-collection-cache-eviction-1.png\" class=\"\" title=\"Hibernate atlassian 下面的评论\">\n<p>点进链接是 GitHub 的 PR 请求，讨论中详细地记录了从贡献者提出 PR 到最后并合并的整个流程。看下来大概就是，贡献者向负责人解释了为了提出这个改动、有负责人担心是不是会影响性能并期望做成可配置的、贡献者支持了配置项、PR 最终被合并。所以问题已经很明了了，功能上是已经被修复了，但是因为做成了配置项，所以默认没有启用，我们需要手动启用这个特性。</p>\n<img src=\"/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/hibernate-automatic-2nd-collection-cache-eviction-2.png\" class=\"\" title=\"变成配置项的 commit\">\n<p>所以我们从这里点进去，去看一下我们怎么才能打开这个特性。最后我们可以看到是在 <code>hibernate-core/src/main/java/org/hibernate/cfg/AvailableSettings.java</code> 这个文件中定义了配置的名字。</p>\n<img src=\"/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/hibernate-automatic-2nd-collection-cache-eviction-3.png\" class=\"\" title=\"配置项的名字\">\n<p>所以到这里，这个问题就算是最终解决了。</p>\n<h3 id=\"三-插曲\"><a class=\"markdownIt-Anchor\" href=\"#三-插曲\"></a> 三、插曲</h3>\n<p>由于项目使用了 <code>spring-boot-starter-data-jpa</code> 依赖，所以这个配置项的设置并不是上面 Hibernate 的改动所提及的，于是继续在 Google 用 <code>auto_evict_collection_cache</code> 作为关键字进行搜索，寻找在 Spring Boot 中的配置方式。最终是得到了答案，Spring Boot 中的配置项为 <code>spring.jpa.properties.auto_evict_collection_cache</code>，不过在此之外还发现了一个小插曲。</p>\n<p><a href=\"https://hibernate.atlassian.net/browse/HHH-10614\">Auto evict collection cache throws exception with null values</a> 中描述了一个人开启了这个特性，然后在一个特定的情况下 Hibernate 会抛出异常。虽然这个问题很快就被解决了，不过现在回来想想，维护者在维护这种已经已经很庞大的项目时，对所有的改动都抱有谨慎的态度还是很有必要的。做成了配置项，虽然一方面会让很多不知道的人继续遇到这个问题，但同时也让很多无关的人避免了可能带来的新问题。所以这两种方案孰优孰劣，可能就见仁见智了吧。</p>\n",
            "tags": [
                "Java",
                "Hibernate"
            ]
        }
    ]
}