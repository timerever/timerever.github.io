<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.timerever.tk</id>
    <title>A Blog • Posts by &#34;git&#34; tag</title>
    <link href="https://blog.timerever.tk" />
    <updated>2017-03-18T03:07:37.000Z</updated>
    <category term="Java" />
    <category term="HttpClient" />
    <category term="Jackson" />
    <category term="Design Pattern" />
    <category term="Docker" />
    <category term="Dockerfile" />
    <category term="Java Web" />
    <category term="Factory Patterns" />
    <category term="Linux" />
    <category term="C" />
    <category term="Android" />
    <category term="Huawei" />
    <category term="CyanogenMod" />
    <category term="Git" />
    <category term="GitHub" />
    <category term="Hibernate" />
    <category term="Kubernetes" />
    <category term="K8s" />
    <category term="K3s" />
    <category term="Keycloak" />
    <category term="OAuth2" />
    <category term="SSO" />
    <category term="VMware" />
    <category term="vmdk" />
    <category term="MySQL" />
    <category term="wget" />
    <category term="Regular Expression" />
    <category term="Sharding" />
    <category term="Sharding-JDBC" />
    <category term="Translate" />
    <category term="Algorithm" />
    <category term="Sort" />
    <category term="Ubuntu" />
    <category term="Ruby" />
    <category term="Jekyll" />
    <category term="Windows" />
    <category term="Regedit" />
    <category term="PowerShell" />
    <entry>
        <id>https://blog.timerever.tk/2017/03/18/git-tutorial/</id>
        <title>Git 简易教程</title>
        <link rel="alternate" href="https://blog.timerever.tk/2017/03/18/git-tutorial/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;一个好早就写了出来的教材，代某位大佬发表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;版本控制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#版本控制&#34;&gt;&lt;/a&gt; 版本控制&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;为什么要进行版本控制？&lt;/strong&gt;  最简单的例子，当我们用文字处理软件工作时（如Word）需要进行修改，而有时候又不确定修改的内容是不是需要的，因此会产生许多个文件，如图：&lt;/p&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-1.png&#34; class=&#34;&#34;&gt;
&lt;p&gt;每一个文件都是在之前的文件基础上进行微小的修改，久而久之，不但文件冗杂，而且还不清楚修改的内容是什么，是一种很杂乱的方式。&lt;/p&gt;
&lt;p&gt;而版本控制就是解决这一问题——通过记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。&lt;/p&gt;
&lt;p&gt;采取版本控制后，你可以将文件还原到之前的状态，比较各状态之间的细节从而查出是修改了哪个地方，找出哪里出了问题。甚至你可以随意删改项目中的文件，照样可以恢复到之前的样子，因而增加了容错率，提供了更多可能性。&lt;/p&gt;
&lt;p&gt;版本控制有三种，第一种是本地式版本控制，也就是在本地的硬盘上用数据库记录历代文件；第二种是集中式版本控制，通过一个服务器，多个用户连接到服务器进行文件的记录。&lt;br /&gt;
而第三种是我们着重介绍的&lt;em&gt;分布式版本控制&lt;/em&gt;，它将前两种结合起来，在本地和服务器都建立数据库，每次工作时从服务器克隆（clone）下来，同时又与服务器交互，从而兼顾协同性和安全性。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们所说的git就是一个分布式版本控制软件，GitHub就是一个git的托管服务。&lt;/em&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h1 id=&#34;git本地操作&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#git本地操作&#34;&gt;&lt;/a&gt; git本地操作&lt;/h1&gt;
&lt;p&gt;git设计简单，是完全分布式，允许成千上万个并行开发的分支(Branch)，有能力管理超大规模的项目，是目前首选的版本控制软件。&lt;/p&gt;
&lt;h2 id=&#34;一-工作流程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一-工作流程&#34;&gt;&lt;/a&gt; 一、工作流程&lt;/h2&gt;
&lt;p&gt;git的三个工作区域，对应着三种状态：&lt;/p&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-2.png&#34; class=&#34;&#34;&gt;
&lt;p&gt;git 工作流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在工作目录中修改文件。（modified）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;暂存文件，将文件的快照放入暂存区域。（staged）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提交更新，找到暂存区域的文件，将快照永久性存储到 git 仓库目录。（committed）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是最基本的流程，需要时刻记住。&lt;/p&gt;
&lt;h2 id=&#34;二-安装git&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#二-安装git&#34;&gt;&lt;/a&gt; 二、安装git&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/downloads&#34;&gt;Git 官方网站&lt;/a&gt;下载对应自己电脑的版本，按照指引进行安装。&lt;/p&gt;
&lt;h2 id=&#34;三-git使用知识&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#三-git使用知识&#34;&gt;&lt;/a&gt; 三、git使用知识&lt;/h2&gt;
&lt;p&gt;首先我们需要在本地创建一个仓库，用于存放历代版本。&lt;/p&gt;
&lt;p&gt;1.命令行中运用cd指令进入项目的目录，输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这将创建一个名为.git的隐藏子目录。&lt;/p&gt;
&lt;p&gt;2.git status:查看哪些文件处于什么状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ git status
    On branch master
    nothing to commit, working directory clean
   （创建git仓库后目录下没有文件时的情况）  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个文件（test）后再使用git status命令，将会看到一个新的提示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ git status
    On branch master
    Your branch is up-to-date with &#39;origin/master&#39;.
    Untracked files:
    (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

        test

    nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)

    （新建的“test”文件出现在Untracked files下）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.git add：跟踪文件&lt;br /&gt;
运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ git add test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时再运行git status，会看到test文件已被跟踪，处于暂存状态(staged)，显示Changes to be committed&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ git status
    On branch master
    Your branch is up-to-date with &#39;origin/master&#39;.
    Changes to be committed:
    (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

        test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.git commit：提交更新至仓库&lt;/p&gt;
&lt;p&gt;先用git status命令确定暂存区域准备妥当，&lt;br /&gt;
再运行$git commit -m ”提交信息”（提交信息指本次提交的说明，类似于注释）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;quot;first&amp;quot;
[master 5e43df6] first
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 test 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时会显示提交成功的信息。&lt;/p&gt;
&lt;p&gt;5.git diff：显示尚未暂存的改动（并不是所有改动）&lt;/p&gt;
&lt;p&gt;6.git rm test：删除暂存区域中的文件test&lt;/p&gt;
&lt;p&gt;7.git log:查看提交历史&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log
commit 5e43df6b6d003ea70444ee3125456fd75b066803
Author: *** &amp;lt;****@gmail.com&amp;gt;
Date:   Thu Mar 16 19:37:52 2017 +0800

first

commit 1c83e2a07f0279ea510e2a323fada53166c3c657
Author: *** &amp;lt;****@gmail.com&amp;gt;
Date:   Thu Mar 16 19:16:26 2017 +0800

test  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.版本回退&lt;/p&gt;
&lt;p&gt;在git log命令中我们可以看到类似&lt;em&gt;5e43…6803&lt;/em&gt;的一大串字符，那就是版本号（commit id）我们可以用 git reset命令回退到之前任何一个版本:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; $ git reset --hard 1c83e2a0
   HEAD is now at 1c83e2a test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（版本号不必补全，Git会自动去查找）&lt;/p&gt;
&lt;p&gt;以上就是git的本地基本操作，包括创建一个仓库，更改、暂存和提交，查看仓库的提交历史，版本回退。&lt;/p&gt;
&lt;h1 id=&#34;分支&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#分支&#34;&gt;&lt;/a&gt; 分支&lt;/h1&gt;
&lt;p&gt;分支是把工作从主线上分离开来，以免影响开发主线。在不同的分支上你可以尝试各种各样的增删改，实现不同的设想。而git的分支模型是它最突出的特点，也是git脱颖而出的原因。&lt;/p&gt;
&lt;h2 id=&#34;一-分支概念&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一-分支概念&#34;&gt;&lt;/a&gt; 一、分支概念&lt;/h2&gt;
&lt;p&gt;在版本回退里，你可以回溯到之前的任意版本，而这些版本都是处于一条时间线上，这条时间线就是一个分支。&lt;br /&gt;
默认的分支为master分支，本身可以看做一个指针，HEAD指针则指向master指针，如图：&lt;/p&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-3.png&#34; class=&#34;&#34;&gt;
&lt;p&gt;每次提交都会多出一个节点，指针也随之移动。&lt;br /&gt;
当我们创建新的分支时，也就创建了一个新的指针，我们通过命令将HEAD指针移到新指针上：&lt;/p&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-4.png&#34; class=&#34;&#34;&gt;
&lt;p&gt;新提交一次后，新指针向前移动，master指针不变，这就产生了分支：&lt;br /&gt;
我们可以将两条分支合并，之后可以删掉新分支。&lt;/p&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-5.png&#34; class=&#34;&#34;&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-6.png&#34; class=&#34;&#34;&gt;
&lt;p&gt;这样就完成了分支的合并。&lt;/p&gt;
&lt;h2 id=&#34;二-分支使用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#二-分支使用&#34;&gt;&lt;/a&gt; 二、分支使用&lt;/h2&gt;
&lt;p&gt;1.git branch：查看当前所有分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch
* master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（*标示当前分支，默认处于master分支）&lt;/p&gt;
&lt;p&gt;2.git branch testing : 创建testing分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch testing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时创建了testing分支，运行git branch命令验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$git branch    
* master
testing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.git checkout testing： 切换到testing分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout testing
Switched to branch &#39;testing&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时主分支位于testing，运行git branch命令验证&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch
  master
* testing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.git merge testing：将master分支和testing分支合并&lt;br /&gt;
（假设处于master分支）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git merge testing
Already up-to-date.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，则会产生冲突从而无法合并，只能手动解决后再合并。&lt;/p&gt;
&lt;p&gt;5.git branch -d删除分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch -d testing
Deleted branch testing (was 1c83e2a).  
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;使用github&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#使用github&#34;&gt;&lt;/a&gt; 使用GitHub&lt;/h1&gt;
&lt;p&gt;GitHub 是最大的 Git 版本库托管商，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道。&lt;/p&gt;
&lt;h3 id=&#34;创建帐户及配置&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建帐户及配置&#34;&gt;&lt;/a&gt; 创建帐户及配置&lt;/h3&gt;
&lt;p&gt;1.访问https://github.com进行注册&lt;/p&gt;
&lt;p&gt;2.SSH访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/.ssh
$ ls
 id_rsa		id_rsa.pub	known_hosts  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;寻找到id_rsa命名的文件，.pub文件是公钥，另一个是私钥。&lt;/p&gt;
&lt;p&gt;如果找不到，可以运行如下命令创建它们&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; $ ssh-keygen  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入github的帐户设置，点击左侧的SSH and GPG keys，将~/.ssh/id_rsa.pub公钥文件的内容粘贴到文本区，然后点击&amp;quot;Add key&amp;quot;&lt;/p&gt;
&lt;p&gt;SSH访问配置成功&lt;/p&gt;
&lt;h3 id=&#34;创建-维护和管理你自己的项目&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建-维护和管理你自己的项目&#34;&gt;&lt;/a&gt; 创建、维护和管理你自己的项目。&lt;/h3&gt;
&lt;p&gt;1.点击页面右上角的＋号，点击New repository按钮&lt;/p&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-7.png&#34; class=&#34;&#34;&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-8.png&#34; class=&#34;&#34;&gt;
&lt;p&gt;Respository name是必填项目，而其余都是选填项，可以默认。&lt;br /&gt;
点击Create respository按钮  ，即创建了一个新的仓库&lt;br /&gt;
这时候可以将项目分享给其他人，通过HTTP和SSH的形式。&lt;/p&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-9.png&#34; class=&#34;&#34;&gt;
&lt;p&gt;2.对仓库进行操作，使本地和github同步&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     $ git remote add origin     **********（仓库地址）   
    （添加远程仓库至本地）
   
     $ git pull --rebase origin master    
    （更新远程更新到本地）

     $ git push -u origin master  
    （将本地仓库和远程仓库合并）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在今后的项目工作中就是用以上命令同步本地和Github，需要记住。&lt;/p&gt;
&lt;p&gt;3.克隆仓库&lt;br /&gt;
我们可以将远程仓库的内容克隆到本地&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; $ git clone git@github.com:Liuwt1997/github-photo.git
Cloning into &#39;github-photo&#39;...
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Receiving objects: 100% (3/3), 196.28 KiB | 67.00 KiB/s, done.
Checking connectivity... done.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时远程仓库的文件全部克隆至本地。&lt;/p&gt;
&lt;p&gt;4.添加合作者&lt;br /&gt;
点击边栏的 “Settings” 链接，然后从左侧菜单中选择 “Collaborators” 。 然后，在输入框中填写用户名，点击 “Add collaborator.” 此时可以给予他们提交的权限。&lt;/p&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-10.png&#34; class=&#34;&#34;&gt;
&lt;p&gt;5.Fork按钮可以将他人项目派生下来，在你的空间中创建一个完全属于你的项目副本。&lt;/p&gt;
&lt;img src=&#34;/2017/03/18/git-tutorial/git-tutorial-11.png&#34; class=&#34;&#34;&gt;
&lt;p&gt;如何对项目做出贡献呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将派生出的副本克隆到本地&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建出名称有意义的分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查改动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将改动提交到分支中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将新分支推送到 GitHub 的副本中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在到 GitHub 上查看之前的项目副本，可以看到 GitHub 提示我们有新的分支，并且显示了一个大大的绿色按钮让我们可以检查我们的改动，并给源项目创建合并请求。&lt;/p&gt;
&lt;p&gt;如果你点击了那个绿色按钮，就会看到一个新页面，在这里我们可以对改动填写标题和描述，让项目的拥有者考虑一下我们的改动。通常花点时间来编写个清晰有用的描述是个不错的主意，这能让作者明白为什么这个改动可以给他的项目带来好处，并且让他接受合并请求。&lt;/p&gt;
&lt;p&gt;以上就是简单的Github的使用方法。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/book/zh/v2&#34;&gt;https://git-scm.com/book/zh/v2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/&#34;&gt;廖雪峰git教程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="Git" />
        <category term="GitHub" />
        <updated>2017-03-18T03:07:37.000Z</updated>
    </entry>
</feed>
