{
    "version": "https://jsonfeed.org/version/1",
    "title": "A Blog • All posts by \"sort\" tag",
    "description": "Just another blog.",
    "home_page_url": "https://blog.timerever.tk",
    "items": [
        {
            "id": "https://blog.timerever.tk/2022/03/03/sort-an-array-in-a-waveform/",
            "url": "https://blog.timerever.tk/2022/03/03/sort-an-array-in-a-waveform/",
            "title": "波浪排序",
            "date_published": "2022-03-03T08:55:42.000Z",
            "content_html": "<p>偶然间看到了一道算法题，第一眼看起来还挺简单，但是想了想发现不止这么简单，应该会有更优解。拿“波浪排序”作为关键字在百度上进行搜索，发现并没有相关题目。又以“sort wave”为关键字在谷歌上进行搜索，终于发现了相关解析，这里用自己的方式记录一下解题思路。</p>\n<p>首先来看题目：</p>\n<blockquote>\n<p>将给定的数组中的元素进行波浪形排序，输出任意正确结果。<br />\n波浪形排序是指: arr[0] ≥ arr[1] ≤ arr[2] ≥ arr[3] ≤ arr[4] ≥ arr[5]<br />\n例如:<br />\n输入: 1, 2, 6, 7, 5, 3, 4<br />\n输出: 4, 1, 7, 5, 6, 2, 3</p>\n</blockquote>\n<p>解法参考：<a href=\"https://www.enjoyalgorithms.com/blog/sort-an-array-in-a-waveform\">Sort an array in a waveform</a></p>\n<span id=\"more\"></span>\n<h3 id=\"一-排序解法\"><a class=\"markdownIt-Anchor\" href=\"#一-排序解法\"></a> 一、排序解法</h3>\n<p>排序解法是最简单也是最容易想到的解法。首先对数组进行排序，升序降序不重要，因为解法有很多种。</p>\n<p>排序后我们可以：</p>\n<ul>\n<li>从两端分别拿取最大值和最小值，逐渐完成排序</li>\n<li>算出数组中间元素，则将整个数组划分为了小半区和大半区，然后同样分别往两端拿取各半区元素，完成排序</li>\n<li>升序排序后，偶数位（非数组下标位）的元素一定会大于等于前面的元素，将偶数位元素分别与前面的元素交换</li>\n</ul>\n<p>因为第三种解法不需要额外的空间占用，所以我们主要关注第三种解法。</p>\n<h4 id=\"图解\"><a class=\"markdownIt-Anchor\" href=\"#图解\"></a> 图解</h4>\n<p>把参考链接里面现成的图拿过来方便理解。</p>\n<p>对原数组进行排序：</p>\n<img src=\"/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-1.png\" class=\"\" title=\"排序后\">\n<p>然后分别交换偶数位及前面的元素：</p>\n<img src=\"/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-2.png\" class=\"\" title=\"交换元素后\">\n<h4 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\"></a> 代码实现</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] sort(<span class=\"keyword\">int</span>[] arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Arrays.sort(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; arr.length; i = i + <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        tmp = arr[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[i - <span class=\"number\">1</span>] = arr[i];</span><br><span class=\"line\">        arr[i] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\"></a> 复杂度分析</h4>\n<p>排序后再遍历处理的时间复杂度为排序的时间复杂度 + 后续遍历处理时间复杂度，最优为：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log_2 n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20696799999999996em;\"><span style=\"top:-2.4558600000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24414em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> + <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> = <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log_2 n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20696799999999996em;\"><span style=\"top:-2.4558600000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24414em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span><br />\n空间复杂度仍然取决于使用的排序算法 + 后续处理是否需要占用空间，最优为：堆排 + 交换解法 = <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"二-一次遍历解决\"><a class=\"markdownIt-Anchor\" href=\"#二-一次遍历解决\"></a> 二、一次遍历解决</h3>\n<p>这道题的最优解在于，我们能否不使用排序，仅使用一次遍历完成波浪排序。</p>\n<p>从上面的结果可以看出，符合要求的答案，偶数位的元素，一定小于等于其前面和其后面的元素（对应题目要求的 arr[0] ≥ arr[1] ≤ arr[2]、arr[2] ≥ arr[3] ≤ arr[4]）。所以我们可以认为，对于每个偶数位元素，其一定是与相邻两个的元素比较中的最小值。那么我们就遍历偶数位元素，与其相邻元素为一组，将其交换为组内的最小值。然后我们可以看到，划分并遍历元素组的时候，遍历步长为 2，而元素为 3 个一组，所以奇数位元素会参与两次比较交换。<br />\n画了个图便于理解，数字是排序完的一个结果，看上去直观一点：</p>\n<img src=\"/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-3.png\" class=\"\" title=\"对元素分组\">\n<p>所以我们还需要解决的问题就是，当一次交换后，比如上图中的 30-10-50 排列好后，在以 20 为中心进行分组交换的时候，50 如果再次被交换后（假如此时值不是 20 而是 100，那么则需要交换 50 和 100），会不会破坏左边已经排列好的结构。这里就需要定义我们的交换策略。</p>\n<p>对于每组 3 个元素，可能会有以下情况并分别进行处理：</p>\n<ul>\n<li>最左端为最小值：那么将最左端与中间进行交换，这样最左端相当于值变大了。而对于前一个元素组，其作为最右端的值，变大并不会影响现有结构</li>\n<li>中间的为最小值：不需要任何操作</li>\n<li>最右端为最小值：将最右端与中间进行交换，最左端未进行变更</li>\n</ul>\n<p>可以看到，基于以上逻辑，重合元素再第二次参与比较时，要么不变，要么变大，均不会影响原有结构。所以基于这种策略，逐渐遍历数组即可。</p>\n<p>最后再来看一下临界情况。</p>\n<ul>\n<li>如果数组长度为奇数，则正好可以完全分组</li>\n<li>如果数组长度为偶数，则最后会有一个元素未参与比较。再看回上面那张图，在已经排列好 30-10-50-20-70-30-80 的情况下\n<ul>\n<li>假设最后的值为 15（即小于等于倒数第二位的值），则无需处理</li>\n<li>假设最后的值为 90（即大于倒数第二位的值），则直接进行交换。由于倒数第二位的元素为上一分组最右端元素，此种交换情况会将其变大，由于上面的逻辑，所以仍不会破坏原有结构</li>\n</ul>\n<img src=\"/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-4.png\" class=\"\" title=\"假设最后的值为 90 的情况\">\n</li>\n</ul>\n<p>所以整体基于这种步长为 2 的遍历和上述交换逻辑，一次遍历就可以完成要求的波浪排序。</p>\n<h4 id=\"代码实现-2\"><a class=\"markdownIt-Anchor\" href=\"#代码实现-2\"></a> 代码实现</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] sort(<span class=\"keyword\">int</span>[] arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; arr.length - <span class=\"number\">1</span>; i = i + <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; arr[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            tmp = arr[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            arr[i - <span class=\"number\">1</span>] = arr[i];</span><br><span class=\"line\">            arr[i] = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; arr[i + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            tmp = arr[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            arr[i + <span class=\"number\">1</span>] = arr[i];</span><br><span class=\"line\">            arr[i] = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 最后的边界</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr.length % <span class=\"number\">2</span> == <span class=\"number\">0</span> &amp;&amp; arr[arr.length - <span class=\"number\">1</span>] &gt; arr[arr.length - <span class=\"number\">2</span>]) &#123;</span><br><span class=\"line\">        tmp = arr[arr.length - <span class=\"number\">2</span>];</span><br><span class=\"line\">        arr[arr.length - <span class=\"number\">2</span>] = arr[arr.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[arr.length - <span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析-2\"></a> 复杂度分析</h4>\n<p>最后再来看一眼复杂度：</p>\n<ul>\n<li>时间复杂度：只需遍历一次数组，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度：只需临时变量进行元素交换，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n",
            "tags": [
                "Algorithm",
                "Sort"
            ]
        }
    ]
}