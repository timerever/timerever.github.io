<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>A Blog • Posts by &#34;sort&#34; tag</title>
        <link>https://blog.timerever.tk</link>
        <description>Just another blog.</description>
        <language>zh-CN</language>
        <pubDate>Thu, 03 Mar 2022 08:55:42 +0000</pubDate>
        <lastBuildDate>Thu, 03 Mar 2022 08:55:42 +0000</lastBuildDate>
        <category>Java</category>
        <category>Jackson</category>
        <category>HttpClient</category>
        <category>Design Pattern</category>
        <category>Docker</category>
        <category>Dockerfile</category>
        <category>Java Web</category>
        <category>Linux</category>
        <category>C</category>
        <category>Android</category>
        <category>Huawei</category>
        <category>CyanogenMod</category>
        <category>Factory Patterns</category>
        <category>Hibernate</category>
        <category>Git</category>
        <category>GitHub</category>
        <category>VMware</category>
        <category>vmdk</category>
        <category>Keycloak</category>
        <category>OAuth2</category>
        <category>SSO</category>
        <category>wget</category>
        <category>Regular Expression</category>
        <category>Algorithm</category>
        <category>Sort</category>
        <category>Ubuntu</category>
        <category>Ruby</category>
        <category>Jekyll</category>
        <category>Windows</category>
        <category>Regedit</category>
        <category>PowerShell</category>
        <item>
            <guid isPermalink="true">https://blog.timerever.tk/2022/03/03/sort-an-array-in-a-waveform/</guid>
            <title>波浪排序</title>
            <link>https://blog.timerever.tk/2022/03/03/sort-an-array-in-a-waveform/</link>
            <category>Algorithm</category>
            <category>Sort</category>
            <pubDate>Thu, 03 Mar 2022 08:55:42 +0000</pubDate>
            <description><![CDATA[ &lt;p&gt;偶然间看到了一道算法题，第一眼看起来还挺简单，但是想了想发现不止这么简单，应该会有更优解。拿“波浪排序”作为关键字在百度上进行搜索，发现并没有相关题目。又以“sort wave”为关键字在谷歌上进行搜索，终于发现了相关解析，这里用自己的方式记录一下解题思路。&lt;/p&gt;
&lt;p&gt;首先来看题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将给定的数组中的元素进行波浪形排序。&lt;br&gt;波浪形排序是指: arr[0] ≥ arr[1] ≤ arr[2] ≥ arr[3] ≤ arr[4] ≥ arr[5]&lt;br&gt;例如:&lt;br&gt;输入: 1, 2, 6, 7, 5, 3, 4&lt;br&gt;输出: 4, 1, 7, 5, 6, 2, 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解法参考：&lt;a href=&#34;https://www.enjoyalgorithms.com/blog/sort-an-array-in-a-waveform&#34;&gt;Sort an array in a waveform&lt;/a&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;h3 id=&#34;一、排序解法&#34;&gt;&lt;a href=&#34;#一、排序解法&#34; class=&#34;headerlink&#34; title=&#34;一、排序解法&#34;&gt;&lt;/a&gt;一、排序解法&lt;/h3&gt;&lt;p&gt;排序解法是最简单也是最容易想到的解法。首先对数组进行排序，升序降序不重要，因为解法有很多种。&lt;/p&gt;
&lt;p&gt;排序后我们可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从两端分别拿取最大值和最小值，逐渐完成排序&lt;/li&gt;
&lt;li&gt;算出数组中间元素，则将整个数组划分为了小半区和大半区，然后同样分别往两端拿取各半区元素，完成排序&lt;/li&gt;
&lt;li&gt;升序排序后，偶数位（非数组下标位）的元素一定会大于等于前面的元素，将偶数位元素分别与前面的元素交换&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;图解&#34;&gt;&lt;a href=&#34;#图解&#34; class=&#34;headerlink&#34; title=&#34;图解&#34;&gt;&lt;/a&gt;图解&lt;/h4&gt;&lt;p&gt;第三种解法不需要额外的空间占用，把现成的图拿过来方便理解。&lt;/p&gt;
&lt;p&gt;排序后：&lt;/p&gt;
&lt;img src=&#34;/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-1.png&#34; class=&#34;&#34; title=&#34;排序后&#34;&gt;

&lt;p&gt;交换元素后：&lt;/p&gt;
&lt;img src=&#34;/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-2.png&#34; class=&#34;&#34; title=&#34;交换元素后&#34;&gt;

&lt;h4 id=&#34;复杂度分析&#34;&gt;&lt;a href=&#34;#复杂度分析&#34; class=&#34;headerlink&#34; title=&#34;复杂度分析&#34;&gt;&lt;/a&gt;复杂度分析&lt;/h4&gt;&lt;p&gt;排序后再遍历处理的时间复杂度为排序的时间复杂度 + 后续遍历处理时间复杂度，最优为：O(n\log_2 n) + O(n) &amp;#x3D; O(n\log_2 n)&lt;br&gt;空间复杂度仍然取决于使用的排序算法 + 后续处理是否需要占用空间，最优为堆排 + 交换解法 &amp;#x3D; O(1)&lt;/p&gt;
&lt;h3 id=&#34;二、一次遍历解决&#34;&gt;&lt;a href=&#34;#二、一次遍历解决&#34; class=&#34;headerlink&#34; title=&#34;二、一次遍历解决&#34;&gt;&lt;/a&gt;二、一次遍历解决&lt;/h3&gt;&lt;p&gt;这道题的最优解在于，我们能否不使用排序，仅使用一次遍历完成波浪排序。&lt;/p&gt;
&lt;p&gt;从上面的结果可以看出，符合要求的答案，偶数位的元素，一定小于等于其前面和其后面的元素（对应题目要求的 arr[0] ≥ arr[1] ≤ arr[2]、arr[2] ≥ arr[3] ≤ arr[4]）。所以我们可以认为，对于每个偶数位元素，其一定是与相邻两个的元素比较中的最小值。那么我们就遍历偶数位元素，与其相邻元素为一组，将其交换为组内的最小值。然后我们可以看到，划分并遍历元素组的时候，遍历步长为 2，而元素为 3 个一组，所以奇数位元素会参与两次比较交换。&lt;br&gt;画了个图便于理解，数是随便写的，看上去直观一点：&lt;/p&gt;
&lt;img src=&#34;/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-3.png&#34; class=&#34;&#34; title=&#34;对元素分组&#34;&gt;

&lt;p&gt;所以我们还需要解决的问题就是，当一次交换后，比如上图中的 30-10-50 排列好后，在以 20 为中心进行分组交换的时候，50 如果再次被交换后，会不会破坏左边已经排列好的结构。这里就需要定义我们的交换策略。&lt;/p&gt;
&lt;p&gt;对于每组 3 个元素，可能会有以下情况并分别进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最左端为最小值：那么将最左端与中间进行交换，这样最左端相当于值变大了。而对于前一个元素组，其作为最右端的值，变大并不会影响现有结构&lt;/li&gt;
&lt;li&gt;中间的为最小值：不需要任何操作&lt;/li&gt;
&lt;li&gt;最右端为最小值：将最右端与中间进行交换，最左端未进行变更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，基于以上逻辑，重合元素再第二次参与比较时，要么不变，要么变大，均不会影响原有结构。所以基于这种策略，逐渐遍历数组即可。&lt;/p&gt;
&lt;p&gt;最后再来看一下临界情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数组长度为奇数，则正好可以完全分组&lt;/li&gt;
&lt;li&gt;如果数组长度为偶数，则最后会有一个元素未参与比较。再看回上面那张图，在已经排列好 30-10-50-20-70-30-80 的情况下&lt;ul&gt;
&lt;li&gt;假设最后的值为 15（即小于等于倒数第二位的值），则无需处理&lt;/li&gt;
&lt;li&gt;假设最后的值为 90（即大于倒数第二位的值），则直接进行交换。由于倒数第二位的元素为上一分组最右端元素，此种交换情况会将其变大，由于上面的逻辑，所以仍不会破坏原有结构 &lt;img src=&#34;/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-4.png&#34; class=&#34;&#34; title=&#34;假设最后的值为 90 的情况&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以整体基于这种步长为 2 的遍历和上述交换逻辑，一次遍历就可以完成要求的波浪排序。&lt;/p&gt;
&lt;h4 id=&#34;复杂度分析-1&#34;&gt;&lt;a href=&#34;#复杂度分析-1&#34; class=&#34;headerlink&#34; title=&#34;复杂度分析&#34;&gt;&lt;/a&gt;复杂度分析&lt;/h4&gt;&lt;p&gt;最后再来看一眼复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：只需遍历一次数组，O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：只需临时变量进行元素交换，O(1)&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
