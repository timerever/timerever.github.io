<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自定义 Jackson Serializer 解决无法序列化 SerialClob 的问题</title>
    <url>/2022/02/09/custom-jackson-serializer-for-clob-type/</url>
    <content><![CDATA[<p>由于种种原因，项目上在做数据查询时，没有选择任何的 ORM 框架而是使用了 <code>JdbcTemplate</code> 进行数据库查询。查询出来也没做太多事情，只是简单地对数据做了下封装，然后直接返回给了前端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(ds);</span><br><span class="line"><span class="type">SqlRowSet</span> <span class="variable">sqlRowSet</span> <span class="operator">=</span> jdbcTemplate.queryForRowSet(sql);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">columnSize</span> <span class="operator">=</span> sqlRowSet.getMetaData().getColumnNames().length;</span><br><span class="line"><span class="keyword">while</span> (sqlRowSet.next()) &#123;</span><br><span class="line">	Map&lt;String, Object&gt; tmp = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnSize; i++) &#123;</span><br><span class="line">		tmp.put(i + <span class="string">&quot;&quot;</span>, sqlRowSet.getObject(i));</span><br><span class="line">	&#125;</span><br><span class="line">	data.add(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来一直岁月静好，知道某一天查了一张新表，然后后台报了异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class java.io.ByteArrayInputStream and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: com.demo.web.rest.util.ResponseEnvelope[&quot;data&quot;]-&gt;com.demo.service.dto.SqlQueryDto[&quot;data&quot;]-&gt;java.util.ArrayList[0]-&gt;java.util.LinkedHashMap[&quot;LOG_MSG&quot;]-&gt;javax.sql.rowset.serial.SerialClob[&quot;asciiStream&quot;])</span><br><span class="line">	at com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:77)</span><br><span class="line">	at com.fasterxml.jackson.databind.SerializerProvider.reportBadDefinition(SerializerProvider.java:1300)</span><br><span class="line">	at com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:400)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.failForEmpty(UnknownSerializer.java:46)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.serialize(UnknownSerializer.java:29)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:728)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:774)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.std.MapSerializer.serializeFields(MapSerializer.java:808)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.std.MapSerializer.serializeWithoutTypeInfo(MapSerializer.java:764)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.std.MapSerializer.serialize(MapSerializer.java:720)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.std.MapSerializer.serialize(MapSerializer.java:35)</span><br><span class="line">	at com.fasterxml.jackson.datatype.hibernate5.PersistentCollectionSerializer.serialize(PersistentCollectionSerializer.java:244)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serializeContents(IndexedListSerializer.java:119)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:79)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer.serialize(IndexedListSerializer.java:18)</span><br><span class="line">	at com.fasterxml.jackson.datatype.hibernate5.PersistentCollectionSerializer.serialize(PersistentCollectionSerializer.java:244)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:728)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:774)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:728)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:774)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider._serialize(DefaultSerializerProvider.java:480)</span><br><span class="line">	at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:319)</span><br><span class="line">	at com.fasterxml.jackson.databind.ObjectWriter$Prefetch.serialize(ObjectWriter.java:1518)</span><br><span class="line">	at com.fasterxml.jackson.databind.ObjectWriter.writeValue(ObjectWriter.java:1007)</span><br><span class="line">	at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.writeInternal(AbstractJackson2HttpMessageConverter.java:454)</span><br><span class="line">	... 123 common frames omitted</span><br></pre></td></tr></table></figure>
<p>乍一看，可以通过提示所说的设置 <code>SerializationFeature.FAIL_ON_EMPTY_BEANS</code> 为 <code>false</code> 来避免这个问题，但这个问题其实远远没有这么简单。</p>
<span id="more"></span>
<h3 id="尝试按照提示解决"><a class="markdownIt-Anchor" href="#尝试按照提示解决"></a> 尝试按照提示解决</h3>
<p>既然异常中已经给出了解决方案，所以我们可以先尝试用给出的方案解决。由于我们是 spring 项目，所以我们可以很简单地通过在 yaml 中添加配置而不是采用写大段代码的方式来设置这个序列化属性：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">serialization:</span></span><br><span class="line">      <span class="attr">FAIL_ON_EMPTY_BEANS:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>让我们再调用下接口。好，没问题，不报错了！再看眼返回值，等等，这是个啥？</p>
<img src="/2022/02/09/custom-jackson-serializer-for-clob-type/custom-jackson-serializer-for-clob-type-1.png" class="" title="并不是所期望的结果">
<p>这个字段明明在数据库中是有值的，而且正常也不会变成这种嵌套结构，所以看来这个解决办法并不可行。</p>
<h3 id="寻找问题根源"><a class="markdownIt-Anchor" href="#寻找问题根源"></a> 寻找问题根源</h3>
<p>所以简单的解决方式不行，就只能按部就班先看问题出在哪里了。废话不多说，既然我们知道了问题出在哪个字段，就直接打个断点先看眼程序拿到的返回值是什么样子。</p>
<p>已知数据库是 H2，对应的字段类型为 <code>CHARACTER LARGE OBJECT</code>，再看眼拿到的值：</p>
<img src="/2022/02/09/custom-jackson-serializer-for-clob-type/custom-jackson-serializer-for-clob-type-2.png" class="" title="实际拿到的返回值">
<p>可以看到，程序所拿到的返回值是 <code>javax.sql.rowset.serial.SerialClob</code> 的对象，而这个对象里面所包含的 <code>clob</code> 字段就是 H2 的 <code>org.h2.jdbc.JdbcClob</code> 对象。</p>
<img src="/2022/02/09/custom-jackson-serializer-for-clob-type/custom-jackson-serializer-for-clob-type-3.png" class="" title="SerialClob 类">
<p>也就是说，默认情况下 Jackson 无法序列化 <code>SerialClob</code> 这个类所创建的对象，是不是由于 <code>clob</code> 字段所包含的具体实现类导致的并没有进一步研究，因为数据库的种类很多，我们需要着手做的是解决这个不能序列化的问题。</p>
<h3 id="自定义-serializer-解决问题"><a class="markdownIt-Anchor" href="#自定义-serializer-解决问题"></a> 自定义 Serializer 解决问题</h3>
<p>我们知道 Jackson 可以通过扩展 <code>Module</code> 来支持更多类型的序列化操作，所以我们也可以采用同样的方式来增加对 <code>SerialClob</code> 的支持。</p>
<p>不过我们不需要自定义 <code>Module</code>，使用自带的 <code>SimpleModule</code> 即可，要做的只是自定义对应的 Serializer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SerialClobSerializer</span> <span class="keyword">extends</span> <span class="title class_">JsonSerializer</span>&lt;SerialClob&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(SerialClob clob, JsonGenerator gen, SerializerProvider serializers)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			gen.writeString(clob.getCharacterStream(), (<span class="type">int</span>) clob.length());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SerialException e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;Serialize SerialClob error&quot;</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后要做的就是将自定义的 <code>SerialClobSerializer</code> 注册到 ObjectMapper 中去，通常网上的方法都是自定义创建全局的 <code>ObjectMapper</code> 供 Spring 使用。这个方法定制化强，完全由自己来创建 <code>ObjectMapper</code>，但个人希望在可以应用 Spring 默认创建的 <code>ObjectMapper</code> 属性的同时，将 <code>SerialClobSerializer</code> 注册进去，所以采用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customSerializerSupport</span><span class="params">()</span> &#123;</span><br><span class="line">        objectMapper.registerModule(<span class="keyword">new</span> <span class="title class_">SimpleModule</span>().addSerializer(SerialClob.class, <span class="keyword">new</span> <span class="title class_">SerialClobSerializer</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，问题就得到了解决，调用接口后不再报错，且可以返回正确的结果。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jackson</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache HttpClient 4.5.x 忽略证书验证</title>
    <url>/2017/04/23/client-custom-ssl/</url>
    <content><![CDATA[<p>在使用 Apache HttpComponents 时，需要访问一个第三方接口进行数据传输，但是由于对方使用的是 Let’s Encrypt 的证书，虽然浏览器是信任的，但是在调试的时候发现程序并不信任,所以采用自定义 SSLContext 的方式解决该问题。</p>
<h3 id="查找官方解决方案"><a class="markdownIt-Anchor" href="#查找官方解决方案"></a> 查找官方解决方案</h3>
<p>作为一只程序猿，翻官方文档肯定是首选方案。官方提供了一种 Custom SSL context 的实现。</p>
<p><a href="http://hc.apache.org/httpcomponents-client-4.5.x/httpclient/examples/org/apache/http/examples/client/ClientCustomSSL.java">http://hc.apache.org/httpcomponents-client-4.5.x/httpclient/examples/org/apache/http/examples/client/ClientCustomSSL.java</a></p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ====================================================================</span></span><br><span class="line"><span class="comment"> * Licensed to the Apache Software Foundation (ASF) under one</span></span><br><span class="line"><span class="comment"> * or more contributor license agreements.  See the NOTICE file</span></span><br><span class="line"><span class="comment"> * distributed with this work for additional information</span></span><br><span class="line"><span class="comment"> * regarding copyright ownership.  The ASF licenses this file</span></span><br><span class="line"><span class="comment"> * to you under the Apache License, Version 2.0 (the</span></span><br><span class="line"><span class="comment"> * &quot;License&quot;); you may not use this file except in compliance</span></span><br><span class="line"><span class="comment"> * with the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing,</span></span><br><span class="line"><span class="comment"> * software distributed under the License is distributed on an</span></span><br><span class="line"><span class="comment"> * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span><br><span class="line"><span class="comment"> * KIND, either express or implied.  See the License for the</span></span><br><span class="line"><span class="comment"> * specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment"> * under the License.</span></span><br><span class="line"><span class="comment"> * ====================================================================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This software consists of voluntary contributions made by many</span></span><br><span class="line"><span class="comment"> * individuals on behalf of the Apache Software Foundation.  For more</span></span><br><span class="line"><span class="comment"> * information on the Apache Software Foundation, please see</span></span><br><span class="line"><span class="comment"> * &lt;http://www.apache.org/&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> org.apache.http.examples.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.SSLConnectionSocketFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.TrustSelfSignedStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.ssl.SSLContexts;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This example demonstrates how to create secure connections with a custom SSL</span></span><br><span class="line"><span class="comment"> * context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientCustomSSL</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Trust own CA and all self-signed certs</span></span><br><span class="line">        <span class="type">SSLContext</span> <span class="variable">sslcontext</span> <span class="operator">=</span> SSLContexts.custom()</span><br><span class="line">                .loadTrustMaterial(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;my.keystore&quot;</span>), <span class="string">&quot;nopassword&quot;</span>.toCharArray(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TrustSelfSignedStrategy</span>())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// Allow TLSv1 protocol only</span></span><br><span class="line">        <span class="type">SSLConnectionSocketFactory</span> <span class="variable">sslsf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SSLConnectionSocketFactory</span>(</span><br><span class="line">                sslcontext,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;TLSv1&quot;</span> &#125;,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                SSLConnectionSocketFactory.getDefaultHostnameVerifier());</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpclient</span> <span class="operator">=</span> HttpClients.custom()</span><br><span class="line">                .setSSLSocketFactory(sslsf)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpGet</span> <span class="variable">httpget</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://httpbin.org/&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Executing request &quot;</span> + httpget.getRequestLine());</span><br><span class="line"></span><br><span class="line">            <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpclient.execute(httpget);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line">                System.out.println(response.getStatusLine());</span><br><span class="line">                EntityUtils.consume(entity);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            httpclient.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于考虑到该接口为第三方接口，对方可能进行证书的更换，再加上由于所传输信息是可以公开的、非重要数据的数据，所以并不采用官方给出的导入证书而使用不进行检查直接信任的方式处理。</p>
<h3 id="定义自己的-sslcontext"><a class="markdownIt-Anchor" href="#定义自己的-sslcontext"></a> 定义自己的 SSLContext</h3>
<p>所以问题的关键在于自定义 <code>SSLContext</code>，查看其 <code>loadTrustMaterial</code> 方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SSLContextBuilder <span class="title function_">loadTrustMaterial</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> KeyStore truststore,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> TrustStrategy trustStrategy)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, KeyStoreException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TrustManagerFactory</span> <span class="variable">tmfactory</span> <span class="operator">=</span> TrustManagerFactory.getInstance(</span><br><span class="line">            TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">    tmfactory.init(truststore);</span><br><span class="line">    <span class="keyword">final</span> TrustManager[] tms = tmfactory.getTrustManagers();</span><br><span class="line">    <span class="keyword">if</span> (tms != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (trustStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tms.length; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">TrustManager</span> <span class="variable">tm</span> <span class="operator">=</span> tms[i];</span><br><span class="line">                <span class="keyword">if</span> (tm <span class="keyword">instanceof</span> X509TrustManager) &#123;</span><br><span class="line">                    tms[i] = <span class="keyword">new</span> <span class="title class_">TrustManagerDelegate</span>(</span><br><span class="line">                            (X509TrustManager) tm, trustStrategy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> TrustManager tm : tms) &#123;</span><br><span class="line">            <span class="built_in">this</span>.trustmanagers.add(tm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这边是使用实现了 <code>TrustStrategy</code> 接口的 <code>TrustSelfSignedStrategy</code> 对 X509 证书进行管理，所以我们需要自定义一个 <code>TrustStrategy</code> 的实例。</p>
<p>先查看 <code>TrustStrategy</code> 接口的源代码，发现除了继承了 <code>org.apache.http.ssl.TrustStrategy</code> 之外没有添加任何内容。由于该类在 http-core 包中，直接反编译查看得：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TrustStrategy</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTrusted</span><span class="params">(X509Certificate[] var1, String var2)</span> <span class="keyword">throws</span> CertificateException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里需要重写 <code>isTrusted</code> 方法，不进行验证，直接返回 <code>true</code>。由于不需要导入 Keystore，所以直接给空值，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SSLContext</span> <span class="variable">sslcontext</span> <span class="operator">=</span> SSLContexts.custom()</span><br><span class="line">	    .loadTrustMaterial(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">TrustStrategy</span>() &#123;</span><br><span class="line">	        <span class="meta">@Override</span></span><br><span class="line">	        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTrusted</span><span class="params">(X509Certificate[] x509Certificates, String s)</span> <span class="keyword">throws</span> CertificateException &#123;</span><br><span class="line">	            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;)</span><br><span class="line">	    .build();</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h3>
<p>修改后的完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.SSLConnectionSocketFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.conn.ssl.TrustStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.ssl.SSLContexts;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyManagementException;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyStoreException;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.CertificateException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by timer on 2017/4/23.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClientCustomSSL</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义 SSLContext 使信任所有证书。</span></span><br><span class="line">        <span class="type">SSLContext</span> <span class="variable">sslcontext</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sslcontext = SSLContexts.custom()</span><br><span class="line">	                .loadTrustMaterial(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">TrustStrategy</span>() &#123;</span><br><span class="line">	                    <span class="meta">@Override</span></span><br><span class="line">	                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTrusted</span><span class="params">(X509Certificate[] x509Certificates, String s)</span> <span class="keyword">throws</span> CertificateException &#123;</span><br><span class="line">	                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	                    &#125;</span><br><span class="line">	                &#125;)</span><br><span class="line">	                .build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyManagementException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyStoreException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅允许 TLSv1 协议</span></span><br><span class="line">        <span class="type">SSLConnectionSocketFactory</span> <span class="variable">sslsf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SSLConnectionSocketFactory</span>(</span><br><span class="line">                sslcontext,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;TLSv1&quot;</span> &#125;,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                SSLConnectionSocketFactory.getDefaultHostnameVerifier());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">CloseableHttpClient</span> <span class="variable">httpclient</span> <span class="operator">=</span> HttpClients.custom().setSSLSocketFactory(sslsf).build()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpGet</span> <span class="variable">httpget</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://httpbin.org/get&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>(<span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpclient.execute(httpget)) &#123;</span><br><span class="line">                <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">                System.out.println(EntityUtils.toString(entity));</span><br><span class="line">                EntityUtils.consume(entity);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功访问，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot;, </span><br><span class="line">    &quot;Connection&quot;: &quot;close&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Apache-HttpClient/4.5.3 (Java/1.8.0_121)&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;origin&quot;: &quot;60.219.211.8&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;https://httpbin.org/get&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：这里访问的并不是一个不受信任的站点，但是实际测试不受信任的站点也可以正常访问。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习之旅（零）：出师不利</title>
    <url>/2017/03/02/docker-learning-trip-0/</url>
    <content><![CDATA[<p>Docker——这是一个自出现以来就发展迅猛并获得成功的引擎。自从选择这个方向学习以来，一直在各个地方看到这个名词，但也只是大概了解到这是一个一般企业才会采用的东西。</p>
<p>寒假放假前的课程设计，邀请了企业的人拿来了企业的真实项目来让我们学习，有幸在课余时间与主管技术的老师咨询讨论了一下。其中有一个话题就说到了 Docker，也是符合之前自己所想，老师也是说，像我们平时自己用，拿自己电脑跑或者租个 vps 什么的也就够了，也是用不上这种东西，不过从交谈中也大概了解到了应用 Docker 的优势，比如统一测试环境，比如秒级启动随时恢复等等等等。</p>
<p>秉承着热爱计算机相关的一切的原则，还是决定先大概看一下这个东西，虽然可能实用性真的接近于零，不过就像自己选择这个专业一样，不是出于为了找工作或者怎样怎样的功利的心态，而是所谓的，真的是“热爱学习”。</p>
<p>所以作为一只准程序猿，那么要做的第一件事便是打开官网寻找官方文档（所谓程序员必会通用技能），然后就是阅读英文文档（另一项必会技能）。</p>
<span id="more"></span>
<h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3>
<p>使用的环境是 Ubuntu 的 16.10，默认的源里有 Docker，只需按照官网手册就可轻松安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable&quot;</span></span><br></pre></td></tr></table></figure>
<p>等等，怎么有些不对，记得以前看到的源的指纹长度比这还要长…</p>
<p>还以为是找错了文档，结果打开历史记录一看原来真的是文档改变了，最显而易见的就是网站的 favicon 颜色变深了，也确定了文档就是在今天中午或下午更新了（明明早上起来还看过的，摔！）。</p>
<p>所以看来是写不成第一篇了，之前被称作 docker 和 docker-engine 的东西已经成为了旧版，现在出现的是 Docker CE 和 Docker EE，文档的开始已经让卸载旧版了。不过可能是因为刚刚更新，Docker CE 和 Docker EE 所指向的链接还不能打开，看来真正的旅程应该是等着文档补全然后再开始了（虽然知道“学习之旅”的翻译是中式英语但是真的找不到合适的翻译了）。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计模式</title>
    <url>/2017/04/28/design-patterns/</url>
    <content><![CDATA[<h1 id="模式和软件模式"><a class="markdownIt-Anchor" href="#模式和软件模式"></a> 模式和软件模式</h1>
<blockquote>
<p>A pattern is a solution to a problem in a context.</p>
</blockquote>
<p><strong>模式</strong> 起源于建筑学，每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式我们可以无数次的重用那些已有的解决方案，无需再重复相同的工作。</p>
<p><strong>软件模式 (Software Patterns)</strong> 是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。软件模式并非仅限于设计模式，它还包括架构模式、分析模式和过程模式等，实际上，在软件开发生命周期的每一个阶段都存在着一些被认同的模式。</p>
<p>在这里主要讨论的是软件设计模式。</p>
<span id="more"></span>
<h2 id="软件架构模式与软件设计模式的比较"><a class="markdownIt-Anchor" href="#软件架构模式与软件设计模式的比较"></a> 软件架构模式与软件设计模式的比较</h2>
<p>简略的来说，架构模式是整体上的大智慧，而软件模式更侧重于小技巧。</p>
<p>这里以 MVC 解决方案为例。</p>
<h2 id="软件架构模式"><a class="markdownIt-Anchor" href="#软件架构模式"></a> 软件架构模式</h2>
<img src="/2017/04/28/design-patterns/design-patterns-1.png" class="" title="MVC软件架构模式">
<h2 id="软件设计模式"><a class="markdownIt-Anchor" href="#软件设计模式"></a> 软件设计模式</h2>
<img src="/2017/04/28/design-patterns/design-patterns-2.png" class="" title="MVC软件设计模式">
<p>所谓软件设计模式：</p>
<ul>
<li>在软件模式中，设计模式是研究最为深入的分支。</li>
<li>设计模式用于在特定的条件下为一些重复出现的软件设计问题提供合理的、有效的解决方案。</li>
<li>是系统地命名、解释和评价某一个重要的可重现的面向对象的设计方案。</li>
<li>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</li>
</ul>
<p>软件设计模式包含几个基本要素：模式名称、问题、解决方案、后果。</p>
<p>一个好的模式必须做到以下几点：</p>
<ul>
<li>解决一个问题：从模式可以得到解，而不仅仅是抽象的原则或策略。</li>
<li>是一个被证明了的概念：模式通过—个记录得到解．而不是通过理论或推测。</li>
<li>解并不是显然的：许多解决问题的方法（例如软件设计范例或方法）是从最基本的原理得到解；而最好的方法是以非直接的方式得到解，对大多数比较困难的设计问题来说，这是必要的。</li>
<li>描述了一种关系：模式并不仅仅描述模块，它给出更深层的系统结构和机理。</li>
<li>模式有重要的人为因素：所有的软件服务于人类的舒适或生活质量，而最好的模式追求它的实用性和美学。</li>
</ul>
<h3 id="软件设计模式分类"><a class="markdownIt-Anchor" href="#软件设计模式分类"></a> 软件设计模式分类</h3>
<p><strong>软件设计模式</strong> 按照不同的分类标准可以分为不同的类别，例如按 <strong>目的</strong> 可以分为 <strong>创建型</strong>、<strong>结构型</strong> 和 <strong>行为型</strong>，按 <strong>范围</strong> 可以分为 <strong>类</strong> 和 <strong>对象</strong>。</p>
<img src="/2017/04/28/design-patterns/design-patterns-3.png" class="" title="软件设计模式分类">
<h4 id="创建型设计模式"><a class="markdownIt-Anchor" href="#创建型设计模式"></a> 创建型设计模式</h4>
<p><strong>创建型模式 (Creational Pattern)</strong> 对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>
<p>创建型模式在创建什么 (What)，由谁创建 (Who)，何时创建 (When) 等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p>
<p>创建型设计模式包含：</p>
<ul>
<li>简单工厂模式</li>
<li>工厂模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
<li>原型模式</li>
<li>单例模式</li>
</ul>
<h4 id="结构型设计模式"><a class="markdownIt-Anchor" href="#结构型设计模式"></a> 结构型设计模式</h4>
<p><strong>结构型模式(Structural Pattern)</strong> 关注如何将现有类或对象组织在一起形成更加强大的结构，不同的结构型模式从不同的角度组合类或对象，它们在尽可能满足各种面向对象设计原则的同时为类或对象的组合提供一系列巧妙的解决方案。</p>
<p>其中，类结构型模式关心类的组合，由多个类组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系；对象结构型模式关心类与对象的组合，通过关联关系，在一个类中定义另一个类的实例对象，然后通过该对象调用相应的方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式名称</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">适配器模式<br>(Adapter Pattern)</td>
<td style="text-align:left">将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。</td>
</tr>
<tr>
<td style="text-align:left">桥接模式<br>(Bridge Pattern)</td>
<td style="text-align:left">将抽象部分与它的实现部分解耦，使得两者都能够独立变化。</td>
</tr>
<tr>
<td style="text-align:left">组合模式<br>(Composite Pattern)</td>
<td style="text-align:left">组合多个对象形成树形结构，以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。</td>
</tr>
<tr>
<td style="text-align:left">装饰模式<br>(Decorator Pattern)</td>
<td style="text-align:left">动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。</td>
</tr>
<tr>
<td style="text-align:left">外观模式<br>(Facade Pattern)</td>
<td style="text-align:left">为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</td>
</tr>
<tr>
<td style="text-align:left">享元模式<br>(Flyweight Pattern)</td>
<td style="text-align:left">运用共享技术有效地支持大量细粒度对象的复用。</td>
</tr>
<tr>
<td style="text-align:left">代理模式<br>(Proxy Pattern)</td>
<td style="text-align:left">给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</td>
</tr>
</tbody>
</table>
<h4 id="行为型设计模式"><a class="markdownIt-Anchor" href="#行为型设计模式"></a> 行为型设计模式</h4>
<p><strong>行为型模式(Behavioral Pattern)</strong> 描述类或对象如何交互及如何分配职责,它主要涉及通过合理的处理方法,达到使系统升级性和维护性提高的目的。</p>
<p>分为：</p>
<ul>
<li>解释器模式 (Interpreter Pattern)</li>
<li>模板方法模式 (Template Method Pattern)</li>
<li>职责链模式 (Chain of Responsibility Pattern)</li>
<li>命令模式 (Command Pattern)</li>
<li>迭代器模式 (Iterator Pattern)</li>
<li>中介者模式 (Mediator Pattern)</li>
<li>备忘录模式 (Memento Pattern)</li>
<li>观察者模式 (Observer Pattern)</li>
<li>状态模式 (State Pattern)</li>
<li>策略模式 (Strategy Pattern)</li>
<li>访问者模式 (Visitor Pattern)</li>
</ul>
<p>由于各设计模式都可以展开去讨论，而此处列举的设计模式众多，故在此不对每个设计模式进行展开讨论，有时间或有需求再单独对某一设计模式进行讨论。</p>
<p><strong>参考：我校教参</strong></p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习之旅（一）：Docker 的安装</title>
    <url>/2017/03/03/docker-learning-trip-1/</url>
    <content><![CDATA[<blockquote>
<p>所以之前弄得都差不多算是白弄了，一切还需要从头开始。</p>
</blockquote>
<p>由于使用的环境为 Ubuntu 的 16.10 最新稳定版本，所以打开 Ubuntu 的文档进行安装，以下命令全部来源于官方文档。</p>
<p>为了防止惨剧的再次发生，记录下此时的版本，页面右上角显示为 Docker 17.03。</p>
<span id="more"></span>
<h3 id="卸载旧版本"><a class="markdownIt-Anchor" href="#卸载旧版本"></a> 卸载旧版本</h3>
<p>文档链接：<a href="https://docs.docker.com/engine/installation/linux/ubuntu/#uninstall-old-versions">https://docs.docker.com/engine/installation/linux/ubuntu/#uninstall-old-versions</a></p>
<p>因为安装了旧版本的 Docker，所以需要先卸载老版本，当然没有安装过就不需要进行这一步了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine</span><br></pre></td></tr></table></figure>
<h3 id="安装-docker"><a class="markdownIt-Anchor" href="#安装-docker"></a> 安装 Docker</h3>
<p>文档链接：<a href="https://docs.docker.com/engine/installation/linux/ubuntu/#install-docker">https://docs.docker.com/engine/installation/linux/ubuntu/#install-docker</a></p>
<p>因为 Docker 是有 Ubuntu 的源的，所以直接采用 apt 安装，方便快捷。</p>
<p>之前忘记说了，此次更新 Docker 有了两个版本，分别是 Docker CE 和 Docker EE。从名字其实就可以大概猜出，一个是普通版（其实是社区版）一个是企业版。所以，当然是选择社区版，而且官方提到了社区版和企业版的安装是有所不同的，在此只记录社区版的安装。</p>
<h4 id="添加源"><a class="markdownIt-Anchor" href="#添加源"></a> 添加源</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>sudo apt-key fingerprint 0EBFCD88</code> 是用来验证源的 key 信息是否匹配，正确的信息应该为 <code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>。</p>
<p>这边使用的是 <code>stable</code> 版本，若要使用更新更快的 <code>edge</code> 版本，只需在最后一行的 <code>stable</code> 后面添加 <code>edge</code> 即可。对于这两个版本，官方解释如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker CE gives you the option to run stable or edge builds.</span><br><span class="line">* Stable builds are released once per quarter.</span><br><span class="line">* Edge builds are released once per month.</span><br></pre></td></tr></table></figure>
<h4 id="安装-docker-2"><a class="markdownIt-Anchor" href="#安装-docker-2"></a> 安装 Docker</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>
<p>这样默认安装的总是最新版本的 Docker ，如果你想安装特定版本的 Docker ，可以使用 <code>sudo apt-get install docker-ce=&lt;VERSION&gt;</code> ，使用 <code>apt-cache madison docker-ce</code> 来显示可以安装的 Docker 版本。</p>
<p>可以通过运行 <code>hello-world</code> 镜像来确认已将 Docker CE 正确安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<h4 id="更新-docker"><a class="markdownIt-Anchor" href="#更新-docker"></a> 更新 Docker</h4>
<p>首先运行 <code>sudo apt-get update</code>，然后根据安装指南选择想要安装的新版本。</p>
<h3 id="linux-下的可选安装步骤"><a class="markdownIt-Anchor" href="#linux-下的可选安装步骤"></a> Linux 下的可选安装步骤</h3>
<p>文档链接：<a href="https://docs.docker.com/engine/installation/linux/linux-postinstall/">https://docs.docker.com/engine/installation/linux/linux-postinstall/</a></p>
<p>此处只列出个人所使用的可选安装。</p>
<h4 id="使用非-root-用户管理-docker"><a class="markdownIt-Anchor" href="#使用非-root-用户管理-docker"></a> 使用非 root 用户管理 Docker</h4>
<p>通过文档我们得知 <code>docker</code> 的守护进程绑定的是 Unix socket，默认情况下该 Unix socket 是属于 root 用户，其他用户只能通过 <code>sudo</code> 进行访问，而 <code>docker</code> 的守护进程一直是由 root 用户运行的。所以如果想不使用 <code>sudo</code> 来使用 Docker，可以把用户添加到 <code>docker</code> 用户组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker # 此处已经存在docker组可不执行操作</span><br><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<p>注销重新登入系统来使用户组更新。</p>
<p>通过不加 <code>sudo</code> 命令的 <code>docker</code> 命令来验证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run hello-world</span><br></pre></td></tr></table></figure>
<h4 id="使-docker-开机自启"><a class="markdownIt-Anchor" href="#使-docker-开机自启"></a> 使 Docker 开机自启</h4>
<p>对于大多数的发行版本（RHEL, CentOS, Fedora, Ubuntu 16.04 and higher）使用 <code>systemd</code> 来管理开机自启动的服务，Ubuntu 14.10 及以下版本使用 <code>upstart</code>。</p>
<ul>
<li><code>systemd</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl enable docker # 开启自启动</span><br><span class="line">$ sudo systemctl disable docker # 关闭自启动</span><br></pre></td></tr></table></figure>
<ul>
<li><code>upstart</code></li>
</ul>
<p>Docker 自动使用 <code>upstart</code> 配置自启动，通过以下命令来禁用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo manual | sudo tee /etc/init/docker.override</span><br></pre></td></tr></table></figure>
<ul>
<li><code>chkconfig</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo chkconfig docker on</span><br></pre></td></tr></table></figure>
<h4 id="设置-http-代理"><a class="markdownIt-Anchor" href="#设置-http-代理"></a> 设置 HTTP 代理</h4>
<p>因为 Docker 的服务器在国外，所以直连的速度很慢，就需要用国内的镜像或者使用 HTTP 代理，这里选择的是使用 HTTP 代理。该文档不在上面的可选安装步骤里，在后面的 Admin Guide 里面，链接：<a href="https://docs.docker.com/engine/admin/systemd/#http-proxy">https://docs.docker.com/engine/admin/systemd/#http-proxy</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">$ vi /etc/systemd/system/docker.service.d/http-proxy.conf</span><br></pre></td></tr></table></figure>
<p>添加下列内容，按实际情况修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot;</span><br></pre></td></tr></table></figure>
<p>或者使用以下内容设置不通过代理的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot; &quot;NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com&quot;</span><br></pre></td></tr></table></figure>
<p>然后继续操作完成配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ systemctl show --property=Environment docker # 验证配置是否已经重载，将显示上面配置的信息</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习之旅（二）：Dockerfile 命令</title>
    <url>/2017/03/05/docker-learning-trip-2/</url>
    <content><![CDATA[<p>本篇是对 <code>Dockerfile</code> 文件的一个介绍，在了解完相关知识后，可以用 <code>Dockerfile</code> 文件创建一个简单的镜像。</p>
<h3 id="参考和推荐"><a class="markdownIt-Anchor" href="#参考和推荐"></a> 参考和推荐</h3>
<p>文档链接：<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#general-guidelines-and-recommendations">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#general-guidelines-and-recommendations</a></p>
<p>更详细的 <code>Dockerfile</code> 参考链接：<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a>，同样适用于下文。</p>
<ul>
<li>容器的生命应该是短暂的</li>
<li>可以使用 <code>.dockerignore</code> 文件来排除文件</li>
<li>避免安装不需要的包</li>
<li>每个容器都应该只有一个关注点</li>
<li>最小化层的数量</li>
<li>整理多行参数</li>
<li>Build 缓存</li>
</ul>
<p>都是一些阅读理解的内容，详细见官方文档。</p>
<span id="more"></span>
<h3 id="dockerfile-指南"><a class="markdownIt-Anchor" href="#dockerfile-指南"></a> Dockerfile 指南</h3>
<p>文档链接：<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#the-dockerfile-instructions">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#the-dockerfile-instructions</a></p>
<p>仅列出各命令简单用法，详细请参照上文列出的官方详细文档。</p>
<h4 id="from"><a class="markdownIt-Anchor" href="#from"></a> FROM</h4>
<p>你可以在现有镜像的基础上构建自己的镜像。</p>
<pre><code>FROM &lt;image&gt;
</code></pre>
<p>Or</p>
<pre><code>FROM &lt;image&gt;:&lt;tag&gt;
</code></pre>
<p>Or</p>
<pre><code>FROM &lt;image&gt;@&lt;digest&gt;
</code></pre>
<h4 id="label"><a class="markdownIt-Anchor" href="#label"></a> LABEL</h4>
<p><code>LABEL</code> 命令用来给镜像添加元数据，可以更好地管理镜像等。</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<p>可在一个命令中使用多个键值对，也可只使用一个。若镜像是以其他镜像 <code>FROM</code> 为基础的，相同的标签将会覆盖原有标签。</p>
<h4 id="run"><a class="markdownIt-Anchor" href="#run"></a> RUN</h4>
<p>RUN指令将在当前映像之上的新层中执行任何命令，并提交执行结果，这个提交的的执行后的镜像将被 <code>Dockerfile</code> 的其余步骤使用。</p>
<p><code>RUN</code> 指令有两种形式：</p>
<ul>
<li><code>RUN &lt;command&gt;</code>（shell 形式，命令在 shell 中运行，对于 Linux 默认为 /bin/sh -c，而对于 Windows 默认为 cmd /S /C）</li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>（执行形式）</li>
</ul>
<h4 id="apt-get"><a class="markdownIt-Anchor" href="#apt-get"></a> APT-GET</h4>
<p>这可能是 <code>RUN</code> 命令的最多使用情况，但是你应该避免使用 <code>RUN apt-get upgrade</code> 或是 <code>dist-upgrade</code>，因为许多“必要”的包将不会在无特权的容器内部被升级。如果一个镜像所包含的基础镜像过期，请联系管理员。</p>
<p>记得将 <code>RUN apt-get update</code> 命令与 <code>apt-get install</code> 命令放在同一个 <code>RUN</code> 声明中，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    package-bar \</span><br><span class="line">    package-baz \</span><br><span class="line">    package-foo</span><br></pre></td></tr></table></figure>
<p>在一个单独的 <code>RUN</code> 声明中使用 <code>apt-get update</code> 将会导致缓存问题和之后的 <code>apt-get install</code> 命令失败。</p>
<h4 id="使用管道"><a class="markdownIt-Anchor" href="#使用管道"></a> 使用管道</h4>
<p>有一些 <code>RUN</code> 命令使用和 Linux 中同样的管道来将一个命令的输入导入到另一个命令当中，符号同样为 <code>|</code>。</p>
<h4 id="cmd"><a class="markdownIt-Anchor" href="#cmd"></a> CMD</h4>
<p><code>CMD</code> 命令的主要作用是给可执行容器提供默认的参数。</p>
<p><code>CMD</code> 命令有三种形式：</p>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>（执行形式，最推荐的形式）</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>（入口点的默认参数）</li>
<li><code>CMD command param1 param2</code>（shell 形式）</li>
</ul>
<p>在一个 <code>Dockerfile</code> 文件中，只能有一个 <code>CMD</code> 指令，如果你列出超过一个的 <code>CMD</code> 指令，只有最后一条会起作用。</p>
<h4 id="expose"><a class="markdownIt-Anchor" href="#expose"></a> EXPOSE</h4>
<p><code>EXPOSE</code> 命令用于开放容器的内部端口，支持环境变量（例如，<code>MYSQL_PORT_3306_TCP</code>）。但是<code>EXPOSE</code> 命令并不能使内部端口对宿主可见，你必须使用 <code>-p</code> 命令来开放特定端口或是使用 <code>-P</code> 命令来开放所有的 <code>EXPOSE</code> 的端口。</p>
<pre><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]
</code></pre>
<h4 id="env"><a class="markdownIt-Anchor" href="#env"></a> ENV</h4>
<p><code>ENV</code> 命令用来更新 <code>PATH</code> 环境变量。</p>
<pre><code>ENV &lt;key&gt; &lt;value&gt;
ENV &lt;key&gt;=&lt;value&gt; ...
</code></pre>
<p>这是<code>ENV</code> 命令的两种使用形式，推荐使用第二种形式。</p>
<h4 id="add-or-copy"><a class="markdownIt-Anchor" href="#add-or-copy"></a> ADD or COPY</h4>
<p><code>ADD</code> 和 <code>COPY</code> 命令拥有相似的功能，通常而言，<code>COPY</code> 因其更加透明而被推荐。但是 <code>COPY</code> 只能拷贝本地文件而 <code>ADD</code> 拥有更多的特性（比如本地 tar 提取和远程 URL 支持）。</p>
<pre><code>ADD/COPY &lt;src&gt;... &lt;dest&gt;
ADD/COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]
</code></pre>
<p>省略众多详细介绍，详见文档。</p>
<h4 id="entrypoint"><a class="markdownIt-Anchor" href="#entrypoint"></a> ENTRYPOINT</h4>
<pre><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]（执行形式，推荐）
ENTRYPOINT command param1 param2（shell 形式）
</code></pre>
<p><code>ENTRYPOINT</code> 命令允许你配置容器使其变成可执行容器。</p>
<h4 id="user"><a class="markdownIt-Anchor" href="#user"></a> USER</h4>
<p><code>USER</code> 可以使容器改变运行用户，通过在 <code>Dockerfile</code> 文件中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的命令来创建用户和组。</p>
<h4 id="workdir"><a class="markdownIt-Anchor" href="#workdir"></a> WORKDIR</h4>
<pre><code>WORKDIR /path/to/workdir
</code></pre>
<p><code>WORKDIR</code> 指令可以设置 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>COPY</code> 和 <code>ADD</code> 指令的工作目录。即使后续并不会使用到 <code>WORKDIR</code> 指令，它仍然会被创建。</p>
<p><code>WORKDIR</code> 指令可在一个 <code>Dockerfile</code> 文件中使用多次。如果给定一个相对路径，那么它会相对于之前的 <code>WORKDIR</code> 指令。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>
<p><code>pwd</code> 的输出将为 <code>/a/b/c</code>。</p>
<p><code>WORKDIR</code> 指令也可解析在之前通过 <code>ENV</code> 指令设置的环境变量。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV DIRPATH /path</span><br><span class="line">WORKDIR $DIRPATH/$DIRNAME</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>
<p><code>pwd</code> 的输出将为 <code>/path/$DIRNAME</code>。</p>
<h4 id="onbuild"><a class="markdownIt-Anchor" href="#onbuild"></a> ONBUILD</h4>
<pre><code>ONBUILD [INSTRUCTION]
</code></pre>
<p><code>ONBUILD</code> 命令在当前 <code>Dockerfile</code> 文件构建完成后执行，也就是该镜像最为其他镜像的父镜像时。它会在子镜像的 <code>Dockerfile</code> 文件中的 <code>FROM</code> 指令后立即被执行。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习之旅（三）：创建基础镜像</title>
    <url>/2017/03/06/docker-learning-trip-3/</url>
    <content><![CDATA[<p>基础镜像，官方说法是 <strong>base image</strong>，官方解释为“ <strong>An image that has no parent is a base image.</strong> ”也就是说，没有父镜像的镜像就是基础镜像，我们要做的就是创建一个基础镜像。</p>
<p>文档链接：<a href="https://docs.docker.com/engine/userguide/eng-image/baseimages/">https://docs.docker.com/engine/userguide/eng-image/baseimages/</a></p>
<span id="more"></span>
<h3 id="使用-tar-创建一个完整镜像"><a class="markdownIt-Anchor" href="#使用-tar-创建一个完整镜像"></a> 使用 <code>tar</code> 创建一个完整镜像</h3>
<p>执行 <code>$ docker run raring cat /etc/lsb-release</code> 命令时报错且解决无果，可能 Debian 的发行版和 Ubuntu还是存在些许差异。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run raring cat /etc/lsb-release</span><br><span class="line">container_linux.go:247: starting container process caused &quot;exec: \&quot;cat\&quot;: executable file not found in $PATH&quot;</span><br><span class="line">docker: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;exec: \&quot;cat\&quot;: executable file not found in $PATH&quot;.</span><br><span class="line">ERRO[0000] error getting events from daemon: net/http: request canceled</span><br></pre></td></tr></table></figure>
<h3 id="使用-scratch-创建一个简单的基础镜像"><a class="markdownIt-Anchor" href="#使用-scratch-创建一个简单的基础镜像"></a> 使用 scratch 创建一个简单的基础镜像</h3>
<p>当 <code>scratch</code> 在 Docker 的库中出现时，你不能 pull、run 或者在其他镜像标记这个名字，但是你可以在你的 <code>Dockerfile</code> 文件中引用它。</p>
<p>例如，使用 <code>scratch</code> 创建一个最小化的容器：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> hello /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/hello&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>然后你可以在当前目录使用 <code>docker build --tag hello .</code> 来构建容器。在这里需要 hello 文件，你可以从 Docker Github 的 <a href="https://github.com/docker-library/hello-world/blob/master/hello.c">示例源代码</a> 中下载并编译，过程如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi Dockerfile</span><br><span class="line">$ wget https://raw.githubusercontent.com/docker-library/hello-world/master/hello.c</span><br><span class="line">$ gcc -o hello -static -nostartfiles hello.c</span><br><span class="line">$ docker build --tag hello .</span><br><span class="line">$ docker run hello</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://cloud.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/engine/userguide/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习之旅（四）：Docker Hub</title>
    <url>/2017/03/09/docker-learning-trip-4/</url>
    <content><![CDATA[<p>Docker Hub 是一个由 Docker 公司负责维护的公共注册中心，它包含了超过 15,000 个可用来下载和构建容器的镜像，并且还提供认证、工作组结构、工作流工具（比如 webhooks）、构建触发器以及私有工具（比如私有仓库可用于存储你并不想公开分享的镜像）。</p>
<h3 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h3>
<p><a href="https://docs.docker.com/docker-hub/">Docker Hub</a> 负责集中用户账号、镜像和公开的命名空间的信息，分别由不同的部分组成：</p>
<ul>
<li>Web UI</li>
<li>Meta-data store (comments, stars, list public repositories)</li>
<li>Authentication service</li>
<li>Tokenization</li>
</ul>
<p>这仅仅是 Docker Hub 的一个基本组成，它对大多数的个人和小型企业是十分有帮助的。在改版后，文档将 Docker Hub 部分独立出去，这里遵循以前的顺序，介绍下 Docker Hub 的基础应用。</p>
<p>有关于 Docker Hub 的文档：<a href="https://docs.docker.com/docker-hub/">https://docs.docker.com/docker-hub/</a></p>
<span id="more"></span>
<h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3>
<p>没有登录帐号的情况下可以 <code>search</code> 或者 <code>pull</code> 镜像，但是不能 <code>push</code> 镜像。</p>
<h3 id="团队和组织"><a class="markdownIt-Anchor" href="#团队和组织"></a> 团队和组织</h3>
<p>太高大上，个人的我用不上，不太了解。</p>
<h3 id="仓库"><a class="markdownIt-Anchor" href="#仓库"></a> 仓库</h3>
<h4 id="搜索镜像"><a class="markdownIt-Anchor" href="#搜索镜像"></a> 搜索镜像</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker search centos</span><br><span class="line">NAME                                 DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                               The official build of CentOS.                   1034      [OK]</span><br><span class="line">ansible/centos7-ansible              Ansible on Centos7                              43                   [OK]</span><br><span class="line">tutum/centos                         Centos image with SSH access. For the root...   13                   [OK]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>没有 <code>/</code> 的镜像说明来自顶层的官方镜像。</p>
<p>可以使用 <code>docker pull &lt;imagename&gt;</code> 下载所需要的镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker pull centos</span><br><span class="line">latest: Pulling from centos</span><br><span class="line">6941bfcbbfca: Pull complete</span><br><span class="line">41459f052977: Pull complete</span><br><span class="line">fd44297e2ddb: Already exists</span><br><span class="line">centos:latest: The image you are pulling has been verified. Important: image verification is a tech preview feature and should not be relied on to provide security.</span><br><span class="line">Digest: sha256:d601d3b928eb2954653c59e65862aabb31edefa868bd5148a41fa45004c12288</span><br><span class="line">Status: Downloaded newer image for centos:latest</span><br></pre></td></tr></table></figure>
<h4 id="查看源标签"><a class="markdownIt-Anchor" href="#查看源标签"></a> 查看源标签</h4>
<p>Docker Hub 的 “Tags” 显示了可以获取的版本和相关联的镜像大小。镜像大小是镜像和累积的所有父镜像之和，也是当你执行 <code>docker save</code> 时创建的 Tar 文件的大小。</p>
<h4 id="创建新仓库"><a class="markdownIt-Anchor" href="#创建新仓库"></a> 创建新仓库</h4>
<p>有 xxxx 的命名规则，文档都有不再赘述，创建完成后就可以使用 <code>docker push</code> 来上传镜像。</p>
<h4 id="上传镜像"><a class="markdownIt-Anchor" href="#上传镜像"></a> 上传镜像</h4>
<p>在往 Docker Hub 上传镜像之前，你需要使用 Docker Hub 的用户名和仓库名来命名本地镜像。你可以通过使用特殊的 <code>:&lt;tag&gt;</code> 标签来往一个仓库添加多个镜像。如果不指明，则默认为 <code>latest</code>。</p>
<p>可以使用 <code>docker build -t &lt;hub-user&gt;/&lt;repo-name&gt;[:&lt;tag&gt;]</code> 在构建镜像时命名，使用 <code>docker tag &lt;existing-image&gt; &lt;hub-user&gt;/&lt;repo-name&gt;[:&lt;tag&gt;]</code> 重命名已经存在的本地镜像，或使用 <code>docker commit &lt;exiting-container&gt; &lt;hub-user&gt;/&lt;repo-name&gt;[:&lt;tag&gt;]</code> 来提交更改。</p>
<p>然后就可以上传镜像。</p>
<pre><code>$ docker push &lt;hub-user&gt;/&lt;repo-name&gt;:&lt;tag&gt;
</code></pre>
<h4 id="省略其余"><a class="markdownIt-Anchor" href="#省略其余"></a> 省略其余</h4>
<p>省略其余还未了解及用到的部分，请自行查阅文档。</p>
<h3 id="自动构建"><a class="markdownIt-Anchor" href="#自动构建"></a> 自动构建</h3>
<p>有其优点，当然也有其缺点，大体上就是通过链接到 GitHub 或是 Bitbucket 然后再使用。虽然使用过这两个 git 的管理工具，但是初入 Docker 暂不打算先了解自动构建，后期有精力或有需求再看。</p>
<h3 id="继续省略其余"><a class="markdownIt-Anchor" href="#继续省略其余"></a> 继续省略其余</h3>
<p>个人认为的入门级应用就这些，其余的不再赘述，有需要的可以自行查看官方文档。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习之旅（五）：Docker 下的 srceenfetch</title>
    <url>/2017/03/11/docker-learning-trip-5/</url>
    <content><![CDATA[<p>在之前介绍了 <code>Dockerfile</code> 文件和 Docker Hub 的使用，现在就来完整的应用其创建一个 Docker 下的 srceenfetch。</p>
<h4 id="关于-srceenfetch"><a class="markdownIt-Anchor" href="#关于-srceenfetch"></a> 关于 srceenfetch</h4>
<p>srceenfetch 基本是我在每一个 Linux 主机都会安装的程序，大概就是用来秀 Linux 和一个简略但直观地展示硬件环境的一个应用程序。</p>
<p>该项目托管在 GitHub，项目地址为：<a href="https://github.com/KittyKatt/screenFetch">https://github.com/KittyKatt/screenFetch</a>。</p>
<span id="more"></span>
<h3 id="创建-docker-hub-仓库"><a class="markdownIt-Anchor" href="#创建-docker-hub-仓库"></a> 创建 Docker Hub 仓库</h3>
<p>在 Docker Hub 网页上创建一个 Docker Hub 仓库，具体操作很简单，不再赘述。</p>
<p>此处创建的仓库为：<code>timerever/screenfetch</code></p>
<h3 id="构建镜像"><a class="markdownIt-Anchor" href="#构建镜像"></a> 构建镜像</h3>
<h4 id="创建-dockerfile-文件"><a class="markdownIt-Anchor" href="#创建-dockerfile-文件"></a> 创建 Dockerfile 文件</h4>
<p>因为 screenfetch 在 Ubuntu 中可以直接通过 <code>apt-get</code> 安装，所以直接使用 Ubuntu 源安装。</p>
<p>创建 <code>Dockerfile</code> 文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ vi Dockerfile</span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y screenfetch</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> screenfetch</span></span><br></pre></td></tr></table></figure>
<h4 id="构建镜像并运行"><a class="markdownIt-Anchor" href="#构建镜像并运行"></a> 构建镜像并运行</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t <span class="string">&quot;timerever/screenfetch&quot;</span> .</span><br><span class="line">$ docker run timerever/screenfetch</span><br></pre></td></tr></table></figure>
<h3 id="上传镜像"><a class="markdownIt-Anchor" href="#上传镜像"></a> 上传镜像</h3>
<pre><code>docker push timerever/screenfetch
</code></pre>
<p>如果没有登录，先使用 <code>docker login</code> 登录即可。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习之旅（六）：使用 Docker 搭建 Java Web 运行环境</title>
    <url>/2017/03/13/docker-learning-trip-6/</url>
    <content><![CDATA[<p>学习 Docker 在一开始肯定不是去学习它的理论（至少对大部分人而言），而是学习它的使用方法进而去使用。大概搭建好了 Docker 的环境，也尝试了创建自己的 Docker 镜像，现在就可以尝试一些比较实用的东西，比如使用 Docker 来搭建 Java Web 运行环境。</p>
<h3 id="寻找镜像"><a class="markdownIt-Anchor" href="#寻找镜像"></a> 寻找镜像</h3>
<p>既然官方的镜像那么多，那么我们为什么不先去看一下官方镜像呢？打开 Docker Hub 一搜索 tomcat，排在第一个的就是。</p>
<p>地址：<a href="https://hub.docker.com/_/tomcat/">https://hub.docker.com/_/tomcat/</a></p>
<p>这边选择 tomcat7 + jre7，但是通过查看构建所使用的 <code>Dockfile</code> 文件发现，tomcat 的官方源采用的是 jre7 是 openJDK7 的 jre，这里需要注意。</p>
<span id="more"></span>
<h3 id="下载运行-tomcat"><a class="markdownIt-Anchor" href="#下载运行-tomcat"></a> 下载运行 tomcat</h3>
<p>tomcat 的默认启动参数为 <code>CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</code>，启动方式为：</p>
<pre><code>docker run -it --rm tomcat:7.0
</code></pre>
<p>使用 <code>http://container-ip:8080</code> 在浏览器访问。</p>
<p>或者将端口映射到本地，运行：</p>
<pre><code>$ docker run -it --rm -p 8888:8080 tomcat:7.0
</code></pre>
<p>然后使用 <code>http://localhost:8888</code> 或是 <code>http://host-ip:8888</code> 访问。</p>
<h3 id="部署-java-web-项目"><a class="markdownIt-Anchor" href="#部署-java-web-项目"></a> 部署 Java Web 项目</h3>
<p>文档上已经说明，对于 tomcat 7 ，tomcat 所在目录为 <code>/usr/local/tomcat</code>，所以对其进行修改完成部署。</p>
<h4 id="复制文件"><a class="markdownIt-Anchor" href="#复制文件"></a> 复制文件</h4>
<p>先使用如下命令启动容器：</p>
<pre><code>$ docker run -it -v /home/ubuntu/tomcat:/mnt/war tomcat:7.0 /bin/bash
</code></pre>
<p>此处相关参数包括：</p>
<ul>
<li><code>-i</code>：表示以“交互模式”运行容器</li>
<li><code>-t</code>：表示容器启动后会进入其命令行</li>
<li><code>-v</code>：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;</li>
</ul>
<p>即运行后进入容器命令行，并将主机的 <code>/home/ubuntu/tomcat</code> 挂载到了容器的 <code>/mnt/war</code> 目录。</p>
<p>然后将部署文件拷贝到主机的 <code>/home/ubuntu/tomcat</code> 目录并继续在容器中操作部署程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd webapps/ROOT/</span></span><br><span class="line"><span class="comment"># rm -rf *</span></span><br><span class="line"><span class="comment"># cp -r /mnt/war/* .</span></span><br><span class="line"><span class="comment"># exit</span></span><br></pre></td></tr></table></figure>
<h4 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h4>
<p>此处需要记住刚才所运行容器的 ID，bash 里面 <code>root@0b2d4744734c</code> 的 ‘root@’ 后面的便是容器 ID。如果已经找不到，可使用 <code>docker ps -a</code> 查看之前所运行过的所有容器。</p>
<p>然后创建镜像。</p>
<pre><code>$ docker commit 0b2d4744734c timerever/javaweb:1.0
</code></pre>
<h3 id="运行镜像"><a class="markdownIt-Anchor" href="#运行镜像"></a> 运行镜像</h3>
<p>使用刚刚自定的名称运行镜像。</p>
<pre><code>docker run -it --rm -p 8888:8080 timerever/javaweb:1.0 catalina.sh run
</code></pre>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>sigaction 自定义信号处理函数的“修复”</title>
    <url>/2017/04/24/fix-sigaction/</url>
    <content><![CDATA[<p>在对嵌入式 Linux 系统程序开发中的进程间通信进行学习时，涉及到了信号集函数组，书中给出的示例如下：</p>
<blockquote>
<p>该实例首先把 SIGQUIT、SIGINT 两个信号加入信号集，然后将该信号集设为阻塞状态，<br />
并在该状态下使程序暂停 5 秒。接下来再将信号集设置为非阻塞状态，再对这两个信号分别<br />
操作，其中 SIGQUIT 执行默认操作，而 SIGINT 执行用户自定义函数的操作。源代码如下<br />
所示：</p>
</blockquote>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_func</span><span class="params">(<span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If you want to quit,please try SIGQUIT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">sigset_t</span> <span class="built_in">set</span>,pendset;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action1</span>,<span class="title">action2</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(sigemptyset(&amp;<span class="built_in">set</span>)&lt;<span class="number">0</span>)</span><br><span class="line">		perror(<span class="string">&quot;sigemptyset&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT)&lt;<span class="number">0</span>)</span><br><span class="line">		perror(<span class="string">&quot;sigaddset&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(sigaddset(&amp;<span class="built_in">set</span>,SIGINT)&lt;<span class="number">0</span>)</span><br><span class="line">		perror(<span class="string">&quot;sigaddset&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>)&lt;<span class="number">0</span>)</span><br><span class="line">		perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;blocked\n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>)&lt;<span class="number">0</span>)</span><br><span class="line">		perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unblock\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(sigismember(&amp;<span class="built_in">set</span>,SIGINT))&#123;</span><br><span class="line">			sigemptyset(&amp;action1.sa_mask);</span><br><span class="line">			action1.sa_handler=my_func;</span><br><span class="line">			sigaction(SIGINT,&amp;action1,<span class="literal">NULL</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sigismember(&amp;<span class="built_in">set</span>,SIGQUIT))&#123;</span><br><span class="line">			sigemptyset(&amp;action2.sa_mask);</span><br><span class="line">			action2.sa_handler = SIG_DFL;</span><br><span class="line">			sigaction(SIGTERM,&amp;action2,<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理论上，按说明所述及代码的编写，使用 <code>Ctrl-C</code> 传递 <code>SIGINT</code> 信号后，会转到自定义处理函数 <code>my_func</code>，但在实际操作中，在进入自定义处理函数后，程序直接退出。<strong>猜测</strong>是由于在进行自定义处理函数后，系统仍然对信号做了默认的处理。</p>
<p>在请教老师后，给出了一种解决方案，对 <code>sigaction</code> 结构体中的 <code>sa_flags</code> 进行赋值，这里先贴出该结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*sa_handler)(<span class="type">int</span> signo);</span><br><span class="line">	<span class="type">sigset_t</span> sa_mask;</span><br><span class="line">	<span class="type">int</span> sa_flags;</span><br><span class="line">	<span class="type">void</span> (*sa_restore)(<span class="type">void</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sa_handler</code> 是一个函数指针，指定信号关联函数，这里除可以是用户自定义的处理函数<br />
外，还可以为 <code>SIG_DFL</code>（采用缺省的处理方式）或 <code>SIG_IGN</code>（忽略信号）。它的处理函数只<br />
有一个参数，即信号值。<br />
<code>sa_mask</code> 是一个信号集，它可以指定在信号处理程序执行过程中哪些信号应当被阻塞，<br />
在调用信号捕获函数之前，该信号集要加入到信号的信号屏蔽字中。<br />
<code>sa_flags</code> 中包含了许多标志位，是对信号进行处理的各个选择项。它的常见可选值如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SA_NODEFER/SA_NOMASK</td>
<td style="text-align:left">当捕捉到此信号时，在执行其信号捕捉函数时，系统不会自动阻塞此信号</td>
</tr>
<tr>
<td style="text-align:left">SA_NOCLDSTOP</td>
<td style="text-align:left">进程忽略子进程产生的任何 SIGSTOP、SIGTSTP、SIGTTIN 和 SIGTTOU 信号</td>
</tr>
<tr>
<td style="text-align:left">SA_RESTART</td>
<td style="text-align:left">可让重启的系统调用重新起作用</td>
</tr>
<tr>
<td style="text-align:left">SA_ONESHOT/SA_RESETHAND</td>
<td style="text-align:left">自定义信号只执行一次，在执行完毕后恢复信号的系统默认动作</td>
</tr>
</tbody>
</table>
<p>将 <code>sigaction</code> 结构体中的 <code>sa_flags</code> 成员赋值为 0，修改后的部分代码如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(sigismember(&amp;<span class="built_in">set</span>,SIGINT))&#123;</span><br><span class="line">		sigemptyset(&amp;action1.sa_mask);</span><br><span class="line">		action1.sa_handler=my_func;</span><br><span class="line">		action1.sa_flags=<span class="number">0</span>; <span class="comment">//添加此行</span></span><br><span class="line">		sigaction(SIGINT,&amp;action1,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sigismember(&amp;<span class="built_in">set</span>,SIGQUIT))&#123;</span><br><span class="line">		sigemptyset(&amp;action2.sa_mask);</span><br><span class="line">		action2.sa_handler = SIG_DFL;</span><br><span class="line">		sigaction(SIGTERM,&amp;action2,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样修改后，程序确实正常运行了。但是根据该书所述和在网上查询，始终未能理解为何这样操作，而且之后尝试赋其他值，依然正常运行。网上国内的氛围就是博客间互相复制互相抄袭，找不到多少主观的分析，所以一直未能解决，仅在此做下记录。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂模式的 Java 实现</title>
    <url>/2017/04/29/factory-patterns-with-java/</url>
    <content><![CDATA[<p><strong>工厂模式</strong> 属于设计模式中创建型数据模式的一种，同时是软件设计模式中最常使用的模式。广义的工厂模式只是一个统称，其还可以继续分为 <strong>简单工厂模式</strong>、<strong>工厂模式</strong> 和 <strong>抽象工厂模式</strong>。这里对这些工厂模式进行说明并使用 Java 代码进行实现。</p>
<span id="more"></span>
<h2 id="通常状态下的对象创建"><a class="markdownIt-Anchor" href="#通常状态下的对象创建"></a> 通常状态下的对象创建</h2>
<p>在不使用任何模式的时候，我们通常是需要什么对象，就直接创建什么对象，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Bicycle.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bicycle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bicycle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Motorbike.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Motorbike</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Motorbike</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bicycle</span> <span class="variable">bicycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bicycle</span>();</span><br><span class="line">        <span class="type">Motorbike</span> <span class="variable">motorbike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Motorbike</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>Bicycle
Motorbike
</code></pre>
<p>这很符合面向对象的思想，通过使用 <code>new</code> 操作符去构造对象实例，但是如果我们需要在实例化时做点初始化的工作呢？我们可以去使用构造方法，但是假如要做的事情很多，代码很长呢？或是我们在创建需要的对象之前必须先生成一些辅助功能的对象，我们就可以使用工厂模式来生成对象，而不用去关心构造对象实例的细节和其复杂的过程。</p>
<h2 id="简单工厂模式"><a class="markdownIt-Anchor" href="#简单工厂模式"></a> 简单工厂模式</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<p><strong>简单工厂模式 (Simple Factory Pattern)</strong> 又称为静态工厂方法 (Static Factory Method) 模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<h3 id="适用环境"><a class="markdownIt-Anchor" href="#适用环境"></a> 适用环境</h3>
<p>在以下情况下可以使用简单工厂模式：</p>
<ul>
<li>工厂类负责创建的对象比较少；由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心；客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>
<h3 id="模式结构"><a class="markdownIt-Anchor" href="#模式结构"></a> 模式结构</h3>
<img src="/2017/04/29/factory-patterns-with-java/factory-patterns-with-java-1.png" class="" title="简单工厂模式模式结构">
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<img src="/2017/04/29/factory-patterns-with-java/factory-patterns-with-java-2.png" class="" title="简单工厂模式举例">
<p>假如这里有一个农场充当工厂类，通过告知农场所需要的水果类型返回所需的水果，即通过传入不同的参数获取不同的对象。</p>
<p>对象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Fruit.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Apple.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Banana.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Banana</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Banana</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Orange.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orange</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* FarmFactory.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FarmFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">get</span><span class="params">(String variety)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (variety) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;banana&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Banana</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;orange&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Orange</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FarmFactory</span> <span class="variable">farmFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FarmFactory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">apple</span> <span class="operator">=</span> farmFactory.get(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">banana</span> <span class="operator">=</span> farmFactory.get(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">orange</span> <span class="operator">=</span> farmFactory.get(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Apple
Banana
Orange
</code></pre>
<h2 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h2>
<h3 id="模式动机"><a class="markdownIt-Anchor" href="#模式动机"></a> 模式动机</h3>
<p>接上面的例子，假如现在农场新种植了一种水果，那么为了完成工厂类的任务，就需要去修改工厂类的代码添加内部逻辑，这显然是违背开闭原则的。</p>
<p>所谓开闭原则，就是对扩展开放，对修改关闭。“开”是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的，“闭”是对原有代码的修改是封闭的，即修改原有的代码对外部的使用是透明的。即对模块行为进行扩展时，不必改动模块的源代码或者二进制代码，所以就出现了工厂模式。</p>
<p>参见：<a href="http://baike.baidu.com/item/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99">http://baike.baidu.com/item/开闭原则</a></p>
<p>现假如有一个生产各种按钮的工厂，通过对该系统进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在在抽象按钮工厂中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。</p>
<img src="/2017/04/29/factory-patterns-with-java/factory-patterns-with-java-3.png" class="" title="简单工厂模式"> <img src="/2017/04/29/factory-patterns-with-java/factory-patterns-with-java-4.png" class="" title="工厂模式">
<h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3>
<p><strong>工厂方法模式 (Factory Method Pattern)</strong> 又称为工厂模式，也叫虚拟构造器 (Virtual Constructor) 模式或者多态工厂 (Polymorphic Factory) 模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪—个具体产品类。</p>
<h3 id="模式结构-2"><a class="markdownIt-Anchor" href="#模式结构-2"></a> 模式结构</h3>
<img src="/2017/04/29/factory-patterns-with-java/factory-patterns-with-java-5.png" class="" title="工厂模式模式结构">
<h3 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> 举例</h3>
<p>对上面的按钮工厂的工厂模式实现。</p>
<p>对象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Button.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CircleButton.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleButton</span> <span class="keyword">extends</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleButton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DiamondButton.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiamondButton</span> <span class="keyword">extends</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DiamondButton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* RectangleButton.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleButton</span> <span class="keyword">extends</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RectangleButton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* FarmFactory.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ButtonFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Button <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CircleButtonFactory.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleButtonFactory</span> <span class="keyword">extends</span> <span class="title class_">ButtonFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CircleButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DiamondButtonFactory.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiamondButtonFactory</span> <span class="keyword">extends</span> <span class="title class_">ButtonFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DiamondButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* RectangleButtonFactory.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleButtonFactory</span> <span class="keyword">extends</span> <span class="title class_">ButtonFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RectangleButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ButtonFactory</span> <span class="variable">buttonFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleButtonFactory</span>();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> buttonFactory.create();</span><br><span class="line">        buttonFactory = <span class="keyword">new</span> <span class="title class_">DiamondButtonFactory</span>();</span><br><span class="line">        button = buttonFactory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>CircleButton
DiamondButton
</code></pre>
<h2 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h2>
<h3 id="模式动机-2"><a class="markdownIt-Anchor" href="#模式动机-2"></a> 模式动机</h3>
<p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重栽的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p>
<p>为了更清晰地理解工厂方法糢式，需要先引入两个概念：</p>
<ul>
<li>产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了—个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>
<li>产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</li>
</ul>
<h3 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h3>
<p><strong>抽象工厂模式 (Abstract Factory Pattern)</strong> 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为 Kit 模式，属于对象创建型模式。</p>
<h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3>
<ul>
<li>当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。</li>
<li>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。</li>
</ul>
<img src="/2017/04/29/factory-patterns-with-java/factory-patterns-with-java-6.png" class="" title="抽象工厂模式应用场景">
<h3 id="模式适用环境"><a class="markdownIt-Anchor" href="#模式适用环境"></a> 模式适用环境</h3>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节。</li>
<li>系统中有多于一个的产品族，但每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li>
</ul>
<h3 id="模式结构-3"><a class="markdownIt-Anchor" href="#模式结构-3"></a> 模式结构</h3>
<img src="/2017/04/29/factory-patterns-with-java/factory-patterns-with-java-7.png" class="" title="抽象工厂模式模式结构">
<h3 id="举例-3"><a class="markdownIt-Anchor" href="#举例-3"></a> 举例</h3>
<p>某软件公司要开发一套界面皮肤库，可以对基于 .NET 平台的桌面软件进行界面美化。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，例如春天 (Spring) 风格的皮肤将提供浅绿色的按钮、绿色边框的文本框和绿色边框的组合框，而夏天 (Summer) 风格的皮肤则提供浅蓝色的按钮、蓝色边框的文本框和蓝色边框的组合框，其结构示意图如下图所示：</p>
<img src="/2017/04/29/factory-patterns-with-java/factory-patterns-with-java-8.png" class="" title="抽象工厂模式举例">
<p>该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤，现使用抽象工厂模式来设计该界面皮肤库。</p>
<p>对象类：</p>
<ul>
<li>ComboBox</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ComboBox.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ComboBox</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SummerComboBox.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SummerComboBox</span> <span class="keyword">extends</span> <span class="title class_">ComboBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummerComboBox</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SpringComboBox.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringComboBox</span> <span class="keyword">extends</span> <span class="title class_">ComboBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpringComboBox</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Button</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Button.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SummerButton.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SummerButton</span> <span class="keyword">extends</span> <span class="title class_">Button</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummerButton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SpringButton.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringButton</span> <span class="keyword">extends</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpringButton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>TextField</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* TextField.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SummerTextField.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SummerTextField</span> <span class="keyword">extends</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummerTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SpringTextField.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTextField</span> <span class="keyword">extends</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpringTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SkinFactory.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SkinFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ComboBox <span class="title function_">getComboBox</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Button <span class="title function_">getButton</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> TextField <span class="title function_">getTextField</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SummerSkinFactory.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SummerSkinFactory</span> <span class="keyword">extends</span> <span class="title class_">SkinFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ComboBox <span class="title function_">getComboBox</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SummerComboBox</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">getButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SummerButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">getTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SummerTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SpringSkinFactory.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSkinFactory</span> <span class="keyword">extends</span> <span class="title class_">SkinFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ComboBox <span class="title function_">getComboBox</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringComboBox</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">getButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">getTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SkinFactory</span> <span class="variable">skinFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SummerSkinFactory</span>();</span><br><span class="line">        <span class="type">ComboBox</span> <span class="variable">comboBox</span> <span class="operator">=</span> skinFactory.getComboBox();</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> skinFactory.getButton();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField</span> <span class="operator">=</span> skinFactory.getTextField();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>SummerComboBox
SummerButton
SummerTextField
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Factory Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>刷 CM 过程中对使用的常用刷机命令的记录</title>
    <url>/2017/02/27/frequently-used-commands-while-flashing-android/</url>
    <content><![CDATA[<blockquote>
<p>终于决定把手里这台荣耀6 刷成 CM，无奈华为只开源 4.4.4 的内核代码，只有 CM 11 的非官方包，哭。</p>
</blockquote>
<p>寻着 XDA 上开发者给的步骤给走，给了两个 rec 一个无法挂载内置储存卡然后没外置的选项（不过也是因为这个才有了本文），一个有问题直接手机进了救援模式，也是汗颜，索性自己手里有 rec 成功解决了。</p>
<p>文中说把刷机包放到外置内存卡目录下，然后进入 rec 傻眼了并没有找到从外置内存卡安装刷机包的选项，于是无奈自己尝试用 adb 传送刷机包。</p>
<p>至于为什么以前不怎么用 adb，主要是由于华为这机子很难从关机状态进入 fastboot，官方让插着 USB 线关机进入但是成功率不高，所以以前都是用论坛正好给出的脚本从开机状态进入，正好熟悉下 adb 记录于此。</p>
<span id="more"></span>
<h3 id="adb-命令"><a class="markdownIt-Anchor" href="#adb-命令"></a> adb 命令</h3>
<ul>
<li><a href="https://developer.android.com/studio/command-line/adb.html">官方文档</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb devices <span class="comment"># 查询连接设备</span></span><br><span class="line">$ adb install &lt;apkfile&gt; <span class="comment"># 安装apk文件</span></span><br><span class="line">$ adb uninstall &lt;package&gt; <span class="comment"># 卸载软件</span></span><br><span class="line">$ adb push foo.txt /sdcard/foo.txt <span class="comment">#发送foo.txt文件</span></span><br><span class="line">$ adb pull /sdcard/foo.txt foo.txt <span class="comment">#传送foo.txt文件到本地</span></span><br><span class="line">$ adb reboot <span class="comment"># 重启</span></span><br><span class="line">$ adb reboot recovery <span class="comment"># 重启到recovery</span></span><br><span class="line">$ adb reboot bootloader <span class="comment"># 重启到fastboot</span></span><br></pre></td></tr></table></figure>
<h3 id="fastboot-命令"><a class="markdownIt-Anchor" href="#fastboot-命令"></a> fastboot 命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fastboot flash boot boot.img <span class="comment"># 刷入boot</span></span><br><span class="line">$ fastboot flash recovery recovery.img <span class="comment"># 同上，刷入recovery</span></span><br><span class="line">......</span><br><span class="line">$ fastboot reboot <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Huawei</tag>
        <tag>CyanogenMod</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 简易教程</title>
    <url>/2017/03/18/git-tutorial/</url>
    <content><![CDATA[<blockquote>
<p>一个好早就写了出来的教材，代某位大佬发表</p>
</blockquote>
<h1 id="版本控制"><a class="markdownIt-Anchor" href="#版本控制"></a> 版本控制</h1>
<p><strong>为什么要进行版本控制？</strong>  最简单的例子，当我们用文字处理软件工作时（如Word）需要进行修改，而有时候又不确定修改的内容是不是需要的，因此会产生许多个文件，如图：</p>
<img src="/2017/03/18/git-tutorial/git-tutorial-1.png" class="">
<p>每一个文件都是在之前的文件基础上进行微小的修改，久而久之，不但文件冗杂，而且还不清楚修改的内容是什么，是一种很杂乱的方式。</p>
<p>而版本控制就是解决这一问题——通过记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<p>采取版本控制后，你可以将文件还原到之前的状态，比较各状态之间的细节从而查出是修改了哪个地方，找出哪里出了问题。甚至你可以随意删改项目中的文件，照样可以恢复到之前的样子，因而增加了容错率，提供了更多可能性。</p>
<p>版本控制有三种，第一种是本地式版本控制，也就是在本地的硬盘上用数据库记录历代文件；第二种是集中式版本控制，通过一个服务器，多个用户连接到服务器进行文件的记录。<br />
而第三种是我们着重介绍的<em>分布式版本控制</em>，它将前两种结合起来，在本地和服务器都建立数据库，每次工作时从服务器克隆（clone）下来，同时又与服务器交互，从而兼顾协同性和安全性。</p>
<p><em>我们所说的git就是一个分布式版本控制软件，GitHub就是一个git的托管服务。</em></p>
<span id="more"></span>
<h1 id="git本地操作"><a class="markdownIt-Anchor" href="#git本地操作"></a> git本地操作</h1>
<p>git设计简单，是完全分布式，允许成千上万个并行开发的分支(Branch)，有能力管理超大规模的项目，是目前首选的版本控制软件。</p>
<h2 id="一-工作流程"><a class="markdownIt-Anchor" href="#一-工作流程"></a> 一、工作流程</h2>
<p>git的三个工作区域，对应着三种状态：</p>
<img src="/2017/03/18/git-tutorial/git-tutorial-2.png" class="">
<p>git 工作流程如下：</p>
<ol>
<li>
<p>在工作目录中修改文件。（modified）</p>
</li>
<li>
<p>暂存文件，将文件的快照放入暂存区域。（staged）</p>
</li>
<li>
<p>提交更新，找到暂存区域的文件，将快照永久性存储到 git 仓库目录。（committed）</p>
</li>
</ol>
<p>这是最基本的流程，需要时刻记住。</p>
<h2 id="二-安装git"><a class="markdownIt-Anchor" href="#二-安装git"></a> 二、安装git</h2>
<p><a href="https://git-scm.com/downloads">Git 官方网站</a>下载对应自己电脑的版本，按照指引进行安装。</p>
<h2 id="三-git使用知识"><a class="markdownIt-Anchor" href="#三-git使用知识"></a> 三、git使用知识</h2>
<p>首先我们需要在本地创建一个仓库，用于存放历代版本。</p>
<p>1.命令行中运用cd指令进入项目的目录，输入</p>
<pre><code>    $ git init
</code></pre>
<p>这将创建一个名为.git的隐藏子目录。</p>
<p>2.git status:查看哪些文件处于什么状态</p>
<pre><code>    $ git status
    On branch master
    nothing to commit, working directory clean
   （创建git仓库后目录下没有文件时的情况）  
</code></pre>
<p>创建一个文件（test）后再使用git status命令，将会看到一个新的提示</p>
<pre><code>    $ git status
    On branch master
    Your branch is up-to-date with 'origin/master'.
    Untracked files:
    (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

        test

    nothing added to commit but untracked files present (use &quot;git add&quot; to track)

    （新建的“test”文件出现在Untracked files下）
</code></pre>
<p>3.git add：跟踪文件<br />
运行</p>
<pre><code>    $ git add test
</code></pre>
<p>此时再运行git status，会看到test文件已被跟踪，处于暂存状态(staged)，显示Changes to be committed</p>
<pre><code>    $ git status
    On branch master
    Your branch is up-to-date with 'origin/master'.
    Changes to be committed:
    (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        test
</code></pre>
<p>4.git commit：提交更新至仓库</p>
<p>先用git status命令确定暂存区域准备妥当，<br />
再运行$git commit -m ”提交信息”（提交信息指本次提交的说明，类似于注释）</p>
<pre><code>$ git commit -m &quot;first&quot;
[master 5e43df6] first
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 test 
</code></pre>
<p>此时会显示提交成功的信息。</p>
<p>5.git diff：显示尚未暂存的改动（并不是所有改动）</p>
<p>6.git rm test：删除暂存区域中的文件test</p>
<p>7.git log:查看提交历史</p>
<pre><code>$ git log
commit 5e43df6b6d003ea70444ee3125456fd75b066803
Author: *** &lt;****@gmail.com&gt;
Date:   Thu Mar 16 19:37:52 2017 +0800

first

commit 1c83e2a07f0279ea510e2a323fada53166c3c657
Author: *** &lt;****@gmail.com&gt;
Date:   Thu Mar 16 19:16:26 2017 +0800

test  
</code></pre>
<p>8.版本回退</p>
<p>在git log命令中我们可以看到类似<em>5e43…6803</em>的一大串字符，那就是版本号（commit id）我们可以用 git reset命令回退到之前任何一个版本:</p>
<pre><code> $ git reset --hard 1c83e2a0
   HEAD is now at 1c83e2a test
</code></pre>
<p>（版本号不必补全，Git会自动去查找）</p>
<p>以上就是git的本地基本操作，包括创建一个仓库，更改、暂存和提交，查看仓库的提交历史，版本回退。</p>
<h1 id="分支"><a class="markdownIt-Anchor" href="#分支"></a> 分支</h1>
<p>分支是把工作从主线上分离开来，以免影响开发主线。在不同的分支上你可以尝试各种各样的增删改，实现不同的设想。而git的分支模型是它最突出的特点，也是git脱颖而出的原因。</p>
<h2 id="一-分支概念"><a class="markdownIt-Anchor" href="#一-分支概念"></a> 一、分支概念</h2>
<p>在版本回退里，你可以回溯到之前的任意版本，而这些版本都是处于一条时间线上，这条时间线就是一个分支。<br />
默认的分支为master分支，本身可以看做一个指针，HEAD指针则指向master指针，如图：</p>
<img src="/2017/03/18/git-tutorial/git-tutorial-3.png" class="">
<p>每次提交都会多出一个节点，指针也随之移动。<br />
当我们创建新的分支时，也就创建了一个新的指针，我们通过命令将HEAD指针移到新指针上：</p>
<img src="/2017/03/18/git-tutorial/git-tutorial-4.png" class="">
<p>新提交一次后，新指针向前移动，master指针不变，这就产生了分支：<br />
我们可以将两条分支合并，之后可以删掉新分支。</p>
<img src="/2017/03/18/git-tutorial/git-tutorial-5.png" class="">
<img src="/2017/03/18/git-tutorial/git-tutorial-6.png" class="">
<p>这样就完成了分支的合并。</p>
<h2 id="二-分支使用"><a class="markdownIt-Anchor" href="#二-分支使用"></a> 二、分支使用</h2>
<p>1.git branch：查看当前所有分支</p>
<pre><code>$ git branch
* master
</code></pre>
<p>（*标示当前分支，默认处于master分支）</p>
<p>2.git branch testing : 创建testing分支</p>
<pre><code>$ git branch testing
</code></pre>
<p>此时创建了testing分支，运行git branch命令验证</p>
<pre><code>$git branch    
* master
testing
</code></pre>
<p>3.git checkout testing： 切换到testing分支</p>
<pre><code>$ git checkout testing
Switched to branch 'testing'
</code></pre>
<p>此时主分支位于testing，运行git branch命令验证</p>
<pre><code>$ git branch
  master
* testing
</code></pre>
<p>4.git merge testing：将master分支和testing分支合并<br />
（假设处于master分支）</p>
<pre><code>$ git merge testing
Already up-to-date.
</code></pre>
<p>如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，则会产生冲突从而无法合并，只能手动解决后再合并。</p>
<p>5.git branch -d删除分支</p>
<pre><code>$ git branch -d testing
Deleted branch testing (was 1c83e2a).  
</code></pre>
<h1 id="使用github"><a class="markdownIt-Anchor" href="#使用github"></a> 使用GitHub</h1>
<p>GitHub 是最大的 Git 版本库托管商，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道。</p>
<h3 id="创建帐户及配置"><a class="markdownIt-Anchor" href="#创建帐户及配置"></a> 创建帐户及配置</h3>
<p>1.访问<a href="https://github.xn--com-k01et46jbm8a8bl">https://github.com进行注册</a></p>
<p>2.SSH访问：</p>
<pre><code>$ cd ~/.ssh
$ ls
 id_rsa		id_rsa.pub	known_hosts  
</code></pre>
<p>寻找到id_rsa命名的文件，.pub文件是公钥，另一个是私钥。</p>
<p>如果找不到，可以运行如下命令创建它们</p>
<pre><code> $ ssh-keygen  
</code></pre>
<p>进入github的帐户设置，点击左侧的SSH and GPG keys，将~/.ssh/id_rsa.pub公钥文件的内容粘贴到文本区，然后点击&quot;Add key&quot;</p>
<p>SSH访问配置成功</p>
<h3 id="创建-维护和管理你自己的项目"><a class="markdownIt-Anchor" href="#创建-维护和管理你自己的项目"></a> 创建、维护和管理你自己的项目。</h3>
<p>1.点击页面右上角的＋号，点击New repository按钮</p>
<img src="/2017/03/18/git-tutorial/git-tutorial-7.png" class="">
<img src="/2017/03/18/git-tutorial/git-tutorial-8.png" class="">
<p>Respository name是必填项目，而其余都是选填项，可以默认。<br />
点击Create respository按钮  ，即创建了一个新的仓库<br />
这时候可以将项目分享给其他人，通过HTTP和SSH的形式。</p>
<img src="/2017/03/18/git-tutorial/git-tutorial-9.png" class="">
<p>2.对仓库进行操作，使本地和github同步</p>
<pre><code>     $ git remote add origin     **********（仓库地址）   
    （添加远程仓库至本地）
   
     $ git pull --rebase origin master    
    （更新远程更新到本地）

     $ git push -u origin master  
    （将本地仓库和远程仓库合并）
</code></pre>
<p>在今后的项目工作中就是用以上命令同步本地和Github，需要记住。</p>
<p>3.克隆仓库<br />
我们可以将远程仓库的内容克隆到本地</p>
<pre><code> $ git clone git@github.com:Liuwt1997/github-photo.git
Cloning into 'github-photo'...
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Receiving objects: 100% (3/3), 196.28 KiB | 67.00 KiB/s, done.
Checking connectivity... done.
</code></pre>
<p>此时远程仓库的文件全部克隆至本地。</p>
<p>4.添加合作者<br />
点击边栏的 “Settings” 链接，然后从左侧菜单中选择 “Collaborators” 。 然后，在输入框中填写用户名，点击 “Add collaborator.” 此时可以给予他们提交的权限。</p>
<img src="/2017/03/18/git-tutorial/git-tutorial-10.png" class="">
<p>5.Fork按钮可以将他人项目派生下来，在你的空间中创建一个完全属于你的项目副本。</p>
<img src="/2017/03/18/git-tutorial/git-tutorial-11.png" class="">
<p>如何对项目做出贡献呢？</p>
<ol>
<li>
<p>将派生出的副本克隆到本地</p>
</li>
<li>
<p>创建出名称有意义的分支</p>
</li>
<li>
<p>修改代码</p>
</li>
<li>
<p>检查改动</p>
</li>
<li>
<p>将改动提交到分支中</p>
</li>
<li>
<p>将新分支推送到 GitHub 的副本中</p>
</li>
</ol>
<p>现在到 GitHub 上查看之前的项目副本，可以看到 GitHub 提示我们有新的分支，并且显示了一个大大的绿色按钮让我们可以检查我们的改动，并给源项目创建合并请求。</p>
<p>如果你点击了那个绿色按钮，就会看到一个新页面，在这里我们可以对改动填写标题和描述，让项目的拥有者考虑一下我们的改动。通常花点时间来编写个清晰有用的描述是个不错的主意，这能让作者明白为什么这个改动可以给他的项目带来好处，并且让他接受合并请求。</p>
<p>以上就是简单的Github的使用方法。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/">廖雪峰git教程</a></li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate 配置自动清除二级缓存之集合缓存</title>
    <url>/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/</url>
    <content><![CDATA[<p>之前在项目上使用了 Hibernate，并开启了基于 caffeine 的二级缓存。因为 Hibernate 会自动处理缓存，所以一直没怎么关注。直到最近，发现在一种特定的情况下，Hibernate 不会自动清除二级缓存里面的集合缓存。问题最后解决起来其实很简单，增加一个配置项的事。不过问题寻求解决的过程还是蛮繁琐的，并没有人能够直接告诉这个问题的答案，在此记录一下这个问题的排查过程。</p>
<blockquote>
<p>太长不看版：Spring Boot 中设置属性 spring.jpa.properties.auto_evict_collection_cache=true 即可解决。</p>
</blockquote>
<span id="more"></span>
<h3 id="一-问题出现"><a class="markdownIt-Anchor" href="#一-问题出现"></a> 一、问题出现</h3>
<p>假定我这里有两个实体，分别为 <code>Parent</code> 和 <code>Child</code>。然后 Parent 与 Child 之间存在一对多的对应关系，即在 Parent 的实体中，存在一个属性 <code>private Set&lt;Child&gt; children</code>，然后我们开启二级缓存 <code>@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)</code>。在这种情况下，我们先访问 Parent 实体并获取其中的 <code>children</code> 属性，确保其已被缓存。然后我们再单独操作 Child，我们新建一个 Child 对象 <code>Child child = new Child()</code> 并设置其 Parent 的值 <code>child.setParent(parent)</code> 并保存 Child 实体 <code>ChildRepository.save(child)</code>。然后我们回过来获取 Parent，会发现 Parent 的 <code>children</code> 的值仍为原数组对象， 没有我们新增的 <code>child</code> 对象。</p>
<p>通过在 Google 上进行搜索，发现 stackoverflow 上存在几个类似的问题，再进一步的搜索后，发现在 Hibernate 官方 Bug 追踪网站上有人归纳并提出了这个问题 <a href="https://hibernate.atlassian.net/browse/HHH-4910">automatic L2 collection cache eviction when an element is added/updated/removed</a>，可以看到不只是自己遇到的新增，修改/删除也会有类似的问题。</p>
<h3 id="二-问题解决"><a class="markdownIt-Anchor" href="#二-问题解决"></a> 二、问题解决</h3>
<p>在上面链接的内容下方，问题提出者给出了一种 workaround 的方案，提供 <code>@PostPersist</code>、<code>@PostRemove</code> 及 <code>@PreUpdate</code> 的监听，并在监听中自动清理缓存。以及在之前查阅 stackoverflow 时，也有人认为，你需要在操作多方元素的时候，同时操作一方对应的集合，对其进行 add/remove 操作。</p>
<p>但不管怎么说，这些都是一些 workaround 方案，因为 Hibernate 本身是有能力自动处理这些事情的。话又说回来，既然问题很早就被提出了，比如这个链接中使用的版本是 <code>3.3.1</code>，同时官方也已经记录了这个问题已经在 <code>4.3.0.Beta5</code> 中被修复了，可是为什么我们还是会遇到这个问题？这个答案其实在下面的评论中。</p>
<img src="/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/hibernate-automatic-2nd-collection-cache-eviction-1.png" class="" title="Hibernate atlassian 下面的评论">
<p>点进链接是 GitHub 的 PR 请求，讨论中详细地记录了从贡献者提出 PR 到最后并合并的整个流程。看下来大概就是，贡献者向负责人解释了为了提出这个改动、有负责人担心是不是会影响性能并期望做成可配置的、贡献者支持了配置项、PR 最终被合并。所以问题已经很明了了，功能上是已经被修复了，但是因为做成了配置项，所以默认没有启用，我们需要手动启用这个特性。</p>
<img src="/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/hibernate-automatic-2nd-collection-cache-eviction-2.png" class="" title="变成配置项的 commit">
<p>所以我们从这里点进去，去看一下我们怎么才能打开这个特性。最后我们可以看到是在 <code>hibernate-core/src/main/java/org/hibernate/cfg/AvailableSettings.java</code> 这个文件中定义了配置的名字。</p>
<img src="/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/hibernate-automatic-2nd-collection-cache-eviction-3.png" class="" title="配置项的名字">
<p>所以到这里，这个问题就算是最终解决了。</p>
<h3 id="三-插曲"><a class="markdownIt-Anchor" href="#三-插曲"></a> 三、插曲</h3>
<p>由于项目使用了 <code>spring-boot-starter-data-jpa</code> 依赖，所以这个配置项的设置并不是上面 Hibernate 的改动所提及的，于是继续在 Google 用 <code>auto_evict_collection_cache</code> 作为关键字进行搜索，寻找在 Spring Boot 中的配置方式。最终是得到了答案，Spring Boot 中的配置项为 <code>spring.jpa.properties.auto_evict_collection_cache</code>，不过在此之外还发现了一个小插曲。</p>
<p><a href="https://hibernate.atlassian.net/browse/HHH-10614">Auto evict collection cache throws exception with null values</a> 中描述了一个人开启了这个特性，然后在一个特定的情况下 Hibernate 会抛出异常。虽然这个问题很快就被解决了，不过现在回来想想，维护者在维护这种已经已经很庞大的项目时，对所有的改动都抱有谨慎的态度还是很有必要的。做成了配置项，虽然一方面会让很多不知道的人继续遇到这个问题，但同时也让很多无关的人避免了可能带来的新问题。所以这两种方案孰优孰劣，可能就见仁见智了吧。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate 解决 Metamodel 属性类型错误问题</title>
    <url>/2021/12/02/hibernate-incorrect-metamodel-with-no-reationship/</url>
    <content><![CDATA[<p>因为项目上使用了 Hibernate Metamodel，而且自定义映射了数据库的 JSON 字段类型，导致生成的 Metamodel 属性类型有误。虽然并没有用映射的这些属性做 <code>CriteriaQuery</code>，所以其实在项目的使用上没有影响，但是启动时还是会报一个 ERROR 日志，所以寻找一个能够根治的解决办法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR org.hibernate.metamodel.internal.MetadataContext [MetadataContext.java:491] - HHH015007: Illegal argument on static metamodel field injection : Foo_#bars; expected type : org.hibernate.metamodel.model.domain.internal.SingularAttributeImpl; encountered type : javax.persistence.metamodel.MapAttribute</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="一-定位问题"><a class="markdownIt-Anchor" href="#一-定位问题"></a> 一、定位问题</h3>
<p><strong>首先是背景信息：</strong> 因为前端需要在数据库存储 JSON 字段，而且现在版本的 MySQL 天然支持 JSON ，所以建表时采用了 JSON 作为字段类型。然后在 JPA 实体层面，引入了 <code>hibernate-types</code> 依赖来增加 Hibernate 对 JSON 的支持，字段属性增加了 <code>@Type(type = &quot;json&quot;)</code> 注解，本身定义为了 <code>Map</code> 类型。</p>
<p>其实在 Hibernate 对 JSON 处理这件事情上，传统方案是通过自定义 <code>Convert</code> 来实现。或者可能不是 JSON Object 而是 JSON Array，但无论是哪种情况，均会遇到同样的问题。</p>
<p>通过报错信息，对代码进行 DEBUG 后得知，Hibernate 在启动时，会根据实体属性是否存在与其他实体的关系，生成不同的 <code>Attribute</code>。比如 OneToMany 一对多关系就会生成 <code>ListAttribute</code> 或 <code>SetAttribute</code>，没有关系的属性都是 <code>SingularAttribute</code>。而启动时通过反射，会 set Metamodel 的对应属性，我们可以在 target 下面看见，Metamodel 的类型为 <code>MapAttribute</code>，所以我们可以确定，问题就出在了生成 Metamodel 的时候。具体是不是直接拿实体定义的数据类型来生成的我没有去看源码，不过可以肯定的是它在判断类型的时候缺少额外的判断。</p>
<h3 id="二-解决问题"><a class="markdownIt-Anchor" href="#二-解决问题"></a> 二、解决问题</h3>
<p>同样作为一个共性问题，在 Goolge 进行搜索后，定位到了一条仍然是 Hibernate 官方 Bug 追踪的链接 <a href="https://hibernate.atlassian.net/browse/HHH-12338">Incorrect metamodel for basic collections</a>。简单的来说，就是当前已经在 5.5.0.Alpha1 的版本中得到了解决，不过如果你认真看了下面整个的 Activity 记录，就会发现仍然是存在一个小插曲。</p>
<h3 id="三-插曲"><a class="markdownIt-Anchor" href="#三-插曲"></a> 三、插曲</h3>
<p>这个问题是在 2018 年的 3 月份被提出来的，而 5.5.0.Alpha1 已经是 2021 年 8 月份的事情了，照理说这么一个小问题不会需要三年多的时间来处理，而这个疑问的答案就在下面的讨论之中。</p>
<p>简单来说，这个问题在当月就被解决掉了，伴随着 5.2.17 的版本发布，这个问题理论上来说就不应该再存在了。然而事与愿违，在 5.2.17 版本发布之后，很快就有人提出了新的问题。在下面的 Comment 中有记录，同时这个人也单独提了一个 issue <a href="https://hibernate.atlassian.net/browse/HHH-12581">NPE for Criteria query containing fetch join as a regression of HHH-12338</a>，即这次的改动造成了 NPE。然后可以看到在另一个维护者与之前 Vlad Mihalcea 的一番讨论之后，他们决定恢复这次的改动。</p>
<img src="/2021/12/02/hibernate-incorrect-metamodel-with-no-reationship/hibernate-incorrect-metamodel-with-no-reationship-1.png" class="" title="revert commit">
<p>但是回退了就意味着问题又回来了，上面提到的 Vlad Mihalcea 从红帽离职，不再维护 Hibernate 还弄了一个新的项目就是上面提到的 <code>hibernate-types</code>。所以其他人在遇到相同的问题时，有部分和我们一样是采用的 <code>hibernate-types</code> 方案，自然而然有人把问题又丢给了 Vlad Mihalcea，不过是在 <code>hibernate-types</code> 项目。</p>
<p>于是 Vlad Mihalcea 在 Github 提了新的 PR，见 <a href="https://github.com/hibernate/hibernate-orm/pull/3254">HHH-12338 - Incorrect metamodel for basic collections</a>。不过很不幸的是，并没有后续。</p>
<p>直到今年的 7 月，又一位开发者忍无可忍决定解决这个问题，提了新的 PR 出来，见 <a href="https://github.com/hibernate/hibernate-orm/pull/4096">HHH-14724 Test-case for metamodel compile error with converters and validation</a>。这次终于引起了重视，并在一番努力之后，终于得到了合并，问题就此解决。</p>
<p>题外话，这件事情，是不是跟前阵子遇到的 <a href="/2021/11/26/hibernate-automatic-2nd-collection-cache-eviction/">Hibernate 配置自动清除二级缓存之集合缓存</a> 里面的插曲有点像？笑。</p>
<h3 id="四-亲力亲为"><a class="markdownIt-Anchor" href="#四-亲力亲为"></a> 四、亲力亲为</h3>
<p>虽说这件事情现在看来终于告一段落了，不过由于时今年 9 月份才最终解决，虽然代码已经被合并到了各个版本的分支中，但 5.4 已经半年没有发过新的版本了。虽说 5.5 和 5.6 的版本已经没问题了，但由于项目框架的问题，并不能直接升级 Hibernate 的版本，而且本来 5.5 的版本就存在很大改动，现有架构并不能保证完全兼容（比如还是上面提到的 <code>hibernate-types</code> 就需要引入另外一个包），所以最后没有办法，只能决定采用重打包的方式自己对源码进行更新。</p>
<p>剩下的事情就不再赘述了，大概流程就是下载 Hibernate 源码，找到 5.4.32.Final 的 tag，在此基础上手动把修复代码的变更拷贝过来，然后改个版本号，发布到私仓，再更改当前项目依赖的版本号，最后成功解决。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>K3s 多节点集群安装</title>
    <url>/2022/01/14/install-k3s-on-multi-node/</url>
    <content><![CDATA[<p>K3s 是轻量级的 Kubernetes，精简了很多 K8s 组件，非常适合在性能较弱的机器上运行，支持 IoT 设备，支持 arm 架构，很适合在 vps 上轻量部署。正好手里有几台 vps，于是决定用 K3s 统一进行管理。</p>
<p>官网：<a href="https://k3s.io/">K3s 官网</a></p>
<p>在官网下面有 Get Started 部分，列出了启动 server 和 agent 节点的简单命令，但是对我们而言还不够，所以参考官网文档进行安装配置。具体的安装文档可以参见：<a href="https://docs.rancher.cn/docs/k3s/installation/install-options/_index">安装选项介绍</a>。</p>
<span id="more"></span>
<h2 id="k3s-安装"><a class="markdownIt-Anchor" href="#k3s-安装"></a> K3s 安装</h2>
<h3 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h3>
<p>由于 K3s 默认运行环境为 containerd，所以为了使用 Docker 作为运行时，需要先在各节点正常安装 Docker，安装过程不再赘述。</p>
<h3 id="安装-master-节点"><a class="markdownIt-Anchor" href="#安装-master-节点"></a> 安装 master 节点</h3>
<p>根据个人需求，按需设置 master 节点的安装参数。由于个人使用，不要多节点部署实现高可用，所以禁用 servicelb 组件。traefik 虽然是 K3s 自带的网络组件，但是其默认会占用 80 和 443 端口，所以也不打算使用。最后完整的安装参数为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sfL https://get.k3s.io | INSTALL_K3S_SKIP_SELINUX_RPM=true INSTALL_K3S_EXEC=&quot;--docker --disable servicelb --disable traefik --disable-cloud-controller&quot; sh -</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或使用国内镜像</span></span><br><span class="line">curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn INSTALL_K3S_SKIP_SELINUX_RPM=true INSTALL_K3S_EXEC=&quot;--docker --disable servicelb --disable traefik --disable-cloud-controller&quot; sh -</span><br></pre></td></tr></table></figure>
<p>安装完成之后我们可以通过 <code>kubectl get node</code> 来看一下节点的情况：</p>
<img src="/2022/01/14/install-k3s-on-multi-node/install-k3s-on-multi-node-1.png" class="" title="节点信息">
<h3 id="安装-agent-节点"><a class="markdownIt-Anchor" href="#安装-agent-节点"></a> 安装 agent 节点</h3>
<p>由于 agent 节点需要与 master 节点进行通信校验，在安装时需要指定 token，所以需要从 master 节点获取安装 token：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu-master:~# cat /var/lib/rancher/k3s/server/node-token</span><br><span class="line">K10995e6e37eec07447411d8f8fcf025c3ed6f9a134e30e896ac4c2a7c4f8e6b587::server:f0af86641d91b09cc7707f25586b77e5</span><br></pre></td></tr></table></figure>
<p>然后与 master 节点类似，指定 agent 节点的参数进行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sfL https://get.k3s.io | K3S_URL=https://MASTER_URL:6443 K3S_TOKEN=NODE_TOKEN INSTALL_K3S_SKIP_SELINUX_RPM=true INSTALL_K3S_EXEC=&quot;--docker&quot; sh -</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或使用国内镜像</span></span><br><span class="line">curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_URL=https://MASTER_URL:6443 K3S_TOKEN=NODE_TOKEN INSTALL_K3S_SKIP_SELINUX_RPM=true INSTALL_K3S_EXEC=&quot;--docker&quot; sh -</span><br></pre></td></tr></table></figure>
<p>然后同样的方式，安装其他 agent 节点。</p>
<h3 id="验证安装"><a class="markdownIt-Anchor" href="#验证安装"></a> 验证安装</h3>
<p>各节点安装完成后，再次在 master 节点查看各节点状态：</p>
<img src="/2022/01/14/install-k3s-on-multi-node/install-k3s-on-multi-node-2.png" class="" title="安装完 agent 节点后的节点信息">
<h2 id="k3s-配置"><a class="markdownIt-Anchor" href="#k3s-配置"></a> K3s 配置</h2>
<h3 id="为-master-分配-worker-角色"><a class="markdownIt-Anchor" href="#为-master-分配-worker-角色"></a> 为 master 分配 worker 角色</h3>
<p>默认情况下，master 节点只有 control-plane 和 master 两个角色，但是由于 master 节点性能过剩，所以可以为 master 节点添加 worker 角色来运行服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl label node $&#123;node&#125; node-role.kubernetes.io/worker=worker</span><br></pre></td></tr></table></figure>
<p>然后我们再来看一下节点信息：</p>
<img src="/2022/01/14/install-k3s-on-multi-node/install-k3s-on-multi-node-3.png" class="" title="为 master 分配 worker 角色后的节点信息">
<h3 id="在-agent-节点上使用-kubectl-命令"><a class="markdownIt-Anchor" href="#在-agent-节点上使用-kubectl-命令"></a> 在 agent 节点上使用 <code>kubectl</code> 命令</h3>
<p>默认 agent 节点安装完毕后，是不能使用 <code>kubectl</code> 命令的：</p>
<img src="/2022/01/14/install-k3s-on-multi-node/install-k3s-on-multi-node-4.png" class="" title="agent 节点默认不能使用 kubectl 命令">
<p>我们可以通过环境变量指定配置文件位置，或在使用 <code>kubectl</code> 命令时指定配置文件位置，但为了方便使用需要 <code>EXPORT</code> 环境变量或者设置 <code>alias</code> 别名。不过我们可以把配置文件放在 <code>~/.kube/config</code>，这样 <code>kubectl</code> 命令可以自动应用配置文件。把 master 节点机器上的 <code>/etc/rancher/k3s/k3s.yaml</code> 文件内容写入到 <code>config</code> 文件，不要忘记修改 server 地址改为 master 节点地址：</p>
<img src="/2022/01/14/install-k3s-on-multi-node/install-k3s-on-multi-node-5.png" class="" title="修改配置文件">
<p>然后我们再来执行下 <code>kubectl</code> 命令，执行正常：</p>
<img src="/2022/01/14/install-k3s-on-multi-node/install-k3s-on-multi-node-6.png" class="" title="应用 kubectl 配置文件">
<h3 id="安装-kubernetes-仪表盘"><a class="markdownIt-Anchor" href="#安装-kubernetes-仪表盘"></a> 安装 Kubernetes 仪表盘</h3>
<blockquote>
<p>参考文档：<a href="https://docs.rancher.cn/docs/k3s/installation/kube-dashboard/_index">Kubernetes 仪表盘</a></p>
</blockquote>
<h4 id="部署仪表盘程序"><a class="markdownIt-Anchor" href="#部署仪表盘程序"></a> 部署仪表盘程序</h4>
<p>首先直接用 Kubernetes 官方的推荐配置进行部署：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GITHUB_URL=https://github.com/kubernetes/dashboard/releases</span><br><span class="line">VERSION_KUBE_DASHBOARD=$(curl -w &#x27;%&#123;url_effective&#125;&#x27; -I -L -s -S $&#123;GITHUB_URL&#125;/latest -o /dev/null | sed -e &#x27;s|.*/||&#x27;)</span><br><span class="line">k3s kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/$&#123;VERSION_KUBE_DASHBOARD&#125;/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>
<h4 id="配置仪表盘角色"><a class="markdownIt-Anchor" href="#配置仪表盘角色"></a> 配置仪表盘角色</h4>
<p>按文档创建用户相关 yml 配置文件:</p>
<p><code>dashboard.admin-user.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure>
<p><code>dashboard.admin-user-role.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure>
<p>然后部署用户角色配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k3s kubectl create -f dashboard.admin-user.yml -f dashboard.admin-user-role.yml</span><br></pre></td></tr></table></figure>
<img src="/2022/01/14/install-k3s-on-multi-node/install-k3s-on-multi-node-7.png" class="" title="应用角色配置">
<p>最后获取仪表盘 token 以供访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k3s kubectl -n kubernetes-dashboard describe secret admin-user-token | grep &#x27;^token&#x27;</span><br></pre></td></tr></table></figure>
<img src="/2022/01/14/install-k3s-on-multi-node/install-k3s-on-multi-node-8.png" class="" title="获取仪表盘 token">
<h4 id="测试访问仪表盘"><a class="markdownIt-Anchor" href="#测试访问仪表盘"></a> 测试访问仪表盘</h4>
<p>由于 Kubernetes 仪表盘运行在集群内部，无法直接从外部访问，所以我们需要使用集群代理。打开一个新窗口，并执行一下命令开启代理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k3s kubectl proxy</span><br></pre></td></tr></table></figure>
<p>然后可以通过 <code>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</code> 来访问 Kubernetes 仪表盘。</p>
<p>或是直接使用端口转发，但是同样需要保持前台运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先获取 service name 和暴露端口</span></span><br><span class="line">kubectl get service -nkubernetes-dashboard</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后进行端口转发</span></span><br><span class="line">kubectl port-forward service/kubernetes-dashboard 8443:443 -nkubernetes-dashboard</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要远端访问的话</span></span><br><span class="line">kubectl port-forward service/kubernetes-dashboard 8443:443 -nkubernetes-dashboard --address 0.0.0.0</span><br></pre></td></tr></table></figure>
<h4 id="配置端口转发"><a class="markdownIt-Anchor" href="#配置端口转发"></a> 配置端口转发</h4>
<p>为了使用方便，当然不能每次都打开终端启动代理来访问 Kubernetes 仪表盘。但是由于我们安装的时候没有安装 lb 和网络组件，所以只能使用 NodePort 来对外暴露服务。同理也适用于其他服务。</p>
<p>首先打开 Kubernetes 仪表盘，切换到 <code>kubernetes-dashboard</code> 命名空间，然后打开 Service tab 页，编辑 kubernetes-dashboard 项。将配置文件中 <code>type</code> 的值改为 <code>NodePort</code>，然后在 <code>ports</code> 下面添加 <code>nodePort: 31001</code>，其中 <code>31001</code> 是宿主机要监听的端口号，修改完成后点击更新应用配置。</p>
<img src="/2022/01/14/install-k3s-on-multi-node/install-k3s-on-multi-node-9.png" class="" title="修改 service">
<p>注意，由于 NodePort 限制，默认限制端口范围只能为 30000-32767，具体可以看 kubernetes 官方文档：<a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#type-nodeport">NodePort 类型</a>。</p>
<p>配置更新后就可以直接从外部用浏览器访问宿主机映射之后的端口，或者再结合反代对外暴露使用。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>K8s</tag>
        <tag>K3s</tag>
      </tags>
  </entry>
  <entry>
    <title>Keycloak 配置自定义社交帐号登录组件</title>
    <url>/2022/01/05/keycloak-custom-idp/</url>
    <content><![CDATA[<p>由于 Keycloak 由红帽开发维护，所以其自带的 Social Identity Providers 都是国外的平台。现有需求对接公司 SSO，且由于国内 OAuth2 协议实现均不标准（公司的也是），所以无法使用 Keycloak 的 OpenID Connect 自定义接入，需要自己扩展 Identity Provider 实现。和国内的微信、钉钉、飞书等系统接入代码类似，但发现现有的接入组件没有实现 <code>UserAttributeMapper</code>，且版本变动，代码并不兼容，所以参考 Github 的实现进行开发。</p>
<blockquote>
<p>Keycloak 使用当前最新版：16.1.0</p>
</blockquote>
<h2 id="一-自定义-identityprovider"><a class="markdownIt-Anchor" href="#一-自定义-identityprovider"></a> 一、自定义 IdentityProvider</h2>
<h3 id="0-引入依赖"><a class="markdownIt-Anchor" href="#0-引入依赖"></a> 0. 引入依赖</h3>
<p>引入 Keycloak 相关依赖，依赖版本要与使用的 Keycloak 版本保持一致，scope 使用 <code>provided</code> 即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.keycloak<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>keycloak-services<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;keycloak.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.keycloak<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>keycloak-server-spi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;keycloak.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.keycloak<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>keycloak-server-spi-private<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;keycloak.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="05-自定义-identityprovider"><a class="markdownIt-Anchor" href="#05-自定义-identityprovider"></a> 0.5. 自定义 IdentityProvider</h3>
<p>由于后续需要，我们先新建一个 IdentityProvider 放在这里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIdentityProvider</span> <span class="keyword">extends</span> <span class="title class_">AbstractOAuth2IdentityProvider</span>&lt;OAuth2IdentityProviderConfig&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">SocialIdentityProvider</span>&lt;OAuth2IdentityProviderConfig&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyIdentityProvider</span><span class="params">(KeycloakSession session, OAuth2IdentityProviderConfig config)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(session, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getDefaultScopes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-自定义-identityproviderfactory"><a class="markdownIt-Anchor" href="#1-自定义-identityproviderfactory"></a> 1. 自定义 IdentityProviderFactory</h3>
<p>我们先来看一下 GitHub 的 <code>GitHubIdentityProviderFactory</code>，很简单，有一个唯一的 <code>PROVIDER_ID</code>，然后 <code>getName</code> 方法返回了一个名称用于展示。</p>
<img src="/2022/01/05/keycloak-custom-idp/keycloak-custom-idp-1.png" class="" title="Github IdentityProviderFactory">
<p>我们照着改一下即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIdentityProviderFactoryFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractIdentityProviderFactory</span>&lt;MyIdentityProvider&gt; <span class="keyword">implements</span> <span class="title class_">SocialIdentityProviderFactory</span>&lt;MyIdentityProvider&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROVIDER_ID</span> <span class="operator">=</span> <span class="string">&quot;my-idp&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My IDP&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyIdentityProvider <span class="title function_">create</span><span class="params">(KeycloakSession session, IdentityProviderModel model)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyIdentityProvider</span>(session, <span class="keyword">new</span> <span class="title class_">OAuth2IdentityProviderConfig</span>(model));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IdentityProviderModel <span class="title function_">createConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OAuth2IdentityProviderConfig</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PROVIDER_ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-自定义-identityprovider"><a class="markdownIt-Anchor" href="#2-自定义-identityprovider"></a> 2. 自定义 IdentityProvider</h3>
<h4 id="先定义并在构造时传入-authorize-token-及-profile-的-url"><a class="markdownIt-Anchor" href="#先定义并在构造时传入-authorize-token-及-profile-的-url"></a> 先定义并在构造时传入 Authorize、Token 及 Profile 的 Url。</h4>
<img src="/2022/01/05/keycloak-custom-idp/keycloak-custom-idp-2.png" class="" title="AUTH URL">
<h4 id="重写必须要求实现的抽象方法"><a class="markdownIt-Anchor" href="#重写必须要求实现的抽象方法"></a> 重写必须要求实现的抽象方法</h4>
<p>重写 <code>getDefaultScopes</code> 的抽象方法，返回自定义 SCOPE。</p>
<h4 id="按需重写方法"><a class="markdownIt-Anchor" href="#按需重写方法"></a> 按需重写方法</h4>
<p>首先重写 <code>supportsExternalExchange</code>方法，写死返回 <code>true</code>。这个官方文档也没有找到注释，但是各实现类均这么重写的，所以这里我们也一起重写。</p>
<p>由于我们继承了 <code>AbstractOAuth2IdentityProvider</code>，剩下的可以直接看抽象类的实现，按需重写非标准定义下无法使用默认实现调用的方法。</p>
<p>比如我需要对应自己系统返回的 <code>User</code> 和 Keycloak 的 <code>User</code> 对象的字段映射关系，所以重写 <code>extractIdentityFromProfile</code> 方法。这个方法也是默认空实现，一定要重写的。我们可以直接拷贝 GitHub 的实现再进行修改，同时，如果我们需要额外存储用户信息，可以使用 <code>setUserAttribute</code> 方法进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> BrokeredIdentityContext <span class="title function_">extractIdentityFromProfile</span><span class="params">(EventBuilder event, JsonNode profile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BrokeredIdentityContext</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrokeredIdentityContext</span>(getJsonProperty(profile, <span class="string">&quot;id&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> getJsonProperty(profile, <span class="string">&quot;login&quot;</span>);</span><br><span class="line">    user.setUsername(username);</span><br><span class="line">    user.setName(getJsonProperty(profile, <span class="string">&quot;name&quot;</span>));</span><br><span class="line">    user.setEmail(getJsonProperty(profile, <span class="string">&quot;email&quot;</span>));</span><br><span class="line">    user.setIdpConfig(getConfig());</span><br><span class="line">    user.setIdp(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    user.setUserAttribute(USER_ATTRIBUTE_EMPLOY_ID, getJsonProperty(profile, USER_ATTRIBUTE_EMPLOY_ID));</span><br><span class="line"></span><br><span class="line">    AbstractJsonUserAttributeMapper.storeUserProfileForMapper(user, profile, getConfig().getAlias());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-重写回调方法"><a class="markdownIt-Anchor" href="#3-重写回调方法"></a> 3. 重写回调方法</h3>
<p>可以发现，我们之前重写的方法，都是接受到回调之后获取 token、获取用户信息的逻辑，如果我们的回调接口传参也不是标准实现的话，那么我们可以重写回调方法。</p>
<h4 id="自定义-endpoint"><a class="markdownIt-Anchor" href="#自定义-endpoint"></a> 自定义 Endpoint</h4>
<p>编写自定义 Endpoint 类，继承 <code>AbstractOAuth2IdentityProvider</code> 内部 <code>Endpoint</code> 类。然后重写 <code>authResponse</code> 方法，自定义接收参数，然后仿照默认实现，通过 <code>authorizationCode</code> 换取用户信息并通过 <code>callback.authenticated(federatedIdentity)</code> 返回。</p>
<h4 id="注册自定义-endpoint"><a class="markdownIt-Anchor" href="#注册自定义-endpoint"></a> 注册自定义 Endpoint</h4>
<p>重写 <code>AbstractOAuth2IdentityProvider</code> 的 <code>callback</code> 方法，返回自定义 Endpoint。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">callback</span><span class="params">(RealmModel realm, AuthenticationCallback callback, EventBuilder event)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyEndpoint</span>(callback, realm, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-注册-identityproviderfactory"><a class="markdownIt-Anchor" href="#4-注册-identityproviderfactory"></a> 4. 注册 IdentityProviderFactory</h3>
<p>在 <code>resources</code> 文件夹下，新建 <code>MEAT-INF</code> 文件夹，并在其下面建立 <code>services</code> 文件。新增 <code>org.keycloak.broker.social.SocialIdentityProviderFactory</code> 文件，在里面直接填写 <code>MyIdentityProviderFactory</code> 的全限定类名即可。</p>
<img src="/2022/01/05/keycloak-custom-idp/keycloak-custom-idp-3.png" class="" title="注册 IdentityProviderFactory">
<hr />
<p>大体流程就是这样，OAuth2 认证后回调默认的 <code>EndPoint</code> 类的 <code>authResponse</code> 方法。如果大体流程标准，且回调参数标准，可以直接参照默认实现，按需重写所调用的 <code>IdentityProvider</code> 方法；如果回调参数会流程不标准，则需要自定义 EndPoint 并进行注册，再重写 <code>authResponse</code> 方法。</p>
<h2 id="二-自定义-identityprovider-配置页"><a class="markdownIt-Anchor" href="#二-自定义-identityprovider-配置页"></a> 二、自定义 IdentityProvider 配置页</h2>
<blockquote>
<p>在新建/编辑 IdentityProvider 时，页面元素是可以配置的，我们可以按需增减页面需要填写的字段。</p>
</blockquote>
<p>首先打开 Keycloak 路径下的 <code>themes\base\admin\resources\partials\</code> 文件夹，我们还是将 <code>realm-identity-provider-github.html</code> 及 <code>realm-identity-provider-github-ext.html</code> 复制并重命名为 <code>realm-identity-provider-my-idp.html</code> 及 <code>realm-identity-provider-my-idp-ext.html</code>。如果不需要自定义，那么保持原样即可。如果需要修改页面字段展示，打开 <code>realm-identity-provider-my-idp.html</code> 文件，将文件内容替换为 <code>realm-identity-provider-social.html</code> 文件的内容，然后再对其进行修改即可。我们可以看到，默认页面就是引用了这个文件的内容。</p>
<h2 id="三-部署-jar-文件"><a class="markdownIt-Anchor" href="#三-部署-jar-文件"></a> 三、部署 jar 文件</h2>
<p><strong>以 standalone 模式为例：</strong></p>
<p>将打包后的 jar 文件复制到 <code>standalone\deployments\</code> 文件夹，不需要重启服务，Keycloak 会自动热部署，并在同级目录生成 <code>文件名.deployed</code> 文件。</p>
<p>如果后续调用时出现 问题，可以参考 <a href="https://stackoverflow.com/questions/57778240/noclassdeffounderror-in-a-provider-jar-when-using-a-class-from-org-keycloak-auth">NoClassDefFoundError in a provider jar</a> 在 <code>maven-jar-plugin</code> 插件配置依赖即可。</p>
<h2 id="四-使用自定义-idp"><a class="markdownIt-Anchor" href="#四-使用自定义-idp"></a> 四、使用自定义 IDP</h2>
<p>回到 Keycloak 后台，右上角点击 <code>Server Info</code>，切到 <code>Providers</code> Tab，如果在 <code>social</code> 栏看到了 <code>my-idp</code>（即上面定义的 provider id），说明部署成功，在 Identity Providers 后台正常新增即可。</p>
<img src="/2022/01/05/keycloak-custom-idp/keycloak-custom-idp-4.png" class="" title="展示出了 my-idp">
<h2 id="五-自定义-userattributemapper"><a class="markdownIt-Anchor" href="#五-自定义-userattributemapper"></a> 五、自定义 UserAttributeMapper</h2>
<p>由于之前我们需要额外储存用户信息，所以在重写 <code>extractIdentityFromProfile</code> 方法时，使用了 <code>setUserAttribute</code> 方法设置自定义属性。但由于 Keycloak 是冗余的用户数据，我们希望用户每次登录后，都可以自动更新用户信息。我们当然可以在 IDP 的配置中设置 <code>Sync Mode</code> 为 <code>force</code> 来每次更新用户信息，但此时只会自动同步更新 User 中 Details Tab 下的基本信息，不会再次同步 Attributes。<br />
正常我们就会想到，可以通过设置 IDP 的 Mappers 来进行属性的放置，结果就会发现，<code>Mapper Type</code> 只有三个 Hardcoded 开头的硬编码的 Mapper。所以为了能够重新使用 <code>Attribute Importer</code>，需要我们自定义一个 <code>UserAttributeMapper</code>。</p>
<h3 id="1-自定义-userattributemapper"><a class="markdownIt-Anchor" href="#1-自定义-userattributemapper"></a> 1. 自定义 UserAttributeMapper</h3>
<p>仍然参考 GitHub 的 <code>GitHubUserAttributeMapper</code>，直接拷贝过来，将 <code>PROVIDER_ID</code> 改成自己的即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserAttributeMapper</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsonUserAttributeMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROVIDER_ID</span> <span class="operator">=</span> <span class="string">&quot;my-idp-user-attribute-mapper&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] cp = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; MyIdentityProviderFactory.PROVIDER_ID &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] getCompatibleProviders() &#123;</span><br><span class="line">		<span class="keyword">return</span> cp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> PROVIDER_ID;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这我们也可以看到，Keycloak 是通过 <code>AbstractJsonUserAttributeMapper</code> 的 <code>getCompatibleProviders</code> 方法来控制 IDP 可选哪些 Mapper 的。</p>
<h3 id="2-注册自定义-userattributemapper"><a class="markdownIt-Anchor" href="#2-注册自定义-userattributemapper"></a> 2. 注册自定义 UserAttributeMapper</h3>
<p>同之前注册 <code>IdentityProvider</code>，在 <code>META-INF/service/</code> 下新建 <code>org.keycloak.broker.provider.IdentityProviderMapper</code> 文件，并在其中填写我们自定义的 UserAttributeMapper 的全限定类名。<br />
最后，别忘了重新打包部署，我们就可以继续在自定义的 IDP 中使用 <code>Attribute Importer</code> 了。</p>
]]></content>
      <categories>
        <category>Keycloak</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Keycloak</tag>
        <tag>OAuth2</tag>
        <tag>SSO</tag>
      </tags>
  </entry>
  <entry>
    <title>合并多个 vmdk 文件</title>
    <url>/2017/03/01/merge-multiple-vmdk&#39;s-into-single-vmdk/</url>
    <content><![CDATA[<p>这是一个上古时代的虚拟机，自从换电脑以来就一直跟随我。虽然当初磁盘选择了单文件存储，然而由于众多快照的原因，又是好多 vmdk 的虚拟磁盘文件躺在硬盘中。因为好多快照都是之前已经被删除了，索性整理了一下虚拟机，并且将多个虚拟磁盘文件合并。</p>
<p>上网寻找了一下解决方案，发现在一个大概是和虚拟化相关的、猜测是 wordpress 官方博客（猜测原因是因为该博客用的是 <a href="http://wordpress.com">wordpress.com</a> 的二级域名）的文章中找到了答案。</p>
<span id="more"></span>
<blockquote>
<p><a href="https://vmexpo.wordpress.com/2014/04/15/how-to-merge-multiple-vmdks-into-single-vmdk/comment-page-1/">https://vmexpo.wordpress.com/2014/04/15/how-to-merge-multiple-vmdks-into-single-vmdk/comment-page-1/</a></p>
</blockquote>
<p>使用的是一个名为 vmware-vdiskmanager 的命令行工具，这个工具可以在 VMware Fusion 或是 VMware Workstation 中找到，所以如果使用的是 VMware Player，那么可以到 VMware 的网站（KB Article 1023856）下载然后放到 VMware Player 的安装路径下。</p>
<p>接下来使用下面命令即可完成操作。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">vmware-vdiskmanager.exe -r &quot;待转换vmdk路径&quot; -t <span class="number">0</span> &quot;新生成的vmdk文件路径&quot;</span><br></pre></td></tr></table></figure>
<p>记得转换完成后，删除或处理掉原来的文件，将新生成的文件名改为原文件名，亦或可以删除虚拟机配置中的原有硬盘并新添转换后的硬盘。</p>
<p>命令操作截图如下。</p>
<img src="/2017/03/01/merge-multiple-vmdk's-into-single-vmdk/conversion-by-cmd.png" class="" title="操作截图">
<blockquote>
<p>Virtual disk conversion successful.</p>
</blockquote>
<p>操作成功完成。</p>
]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>VMware</tag>
        <tag>vmdk</tag>
      </tags>
  </entry>
  <entry>
    <title>重新弄好后的第一篇文章</title>
    <url>/2017/01/25/my-first-article/</url>
    <content><![CDATA[<p>经历了一番挫折，最后算是成功地把 blog 重新（也是从新）部署在了 github，对自己而言还算深夜的时候终于写下了这些东西。</p>
<p>看来我以后要重视下 github 上的项目了，至少不能这么乱糟糟了。</p>
<p>还有，要学习下makedown语法了。</p>
]]></content>
  </entry>
  <entry>
    <title>wget 使用代理</title>
    <url>/2017/03/06/proxy-with-wget/</url>
    <content><![CDATA[<p><code>wget</code> 是 Linux 下常用的一个命令行下载工具。由于此次需要下载的文件在国外，所以速度缓慢，然后就想到使用代理进行下载。使用 <code>--help</code> 查询了一番，发现并没有可以设置代理的地方，倒是有不走代理的选项，汗。</p>
<p>因为是在终端使用，所以并不想使用全局代理，上网搜寻了一下关于 <code>wget</code> 使用代理的使用方法。</p>
<ol>
<li>
<p>修改 .wgetrc 文件</p>
<p>.wgetrc 文件位于 $HOME 目录下，修改添加代理设置。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vi .wgetrc</span><br><span class="line">use_proxy=on</span><br><span class="line">http_proxy=http://ip:port</span><br></pre></td></tr></table></figure>
</li>
</ol>
<span id="more"></span>
<ol start="2">
<li>
<p>设置环境变量</p>
<p>通过环境变量使终端使用代理。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ export http_proxy=&quot;ip:port&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>wget</code> 的 <code>-e</code> 选项</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget --help</span><br><span class="line">GNU Wget 1.15, a non-interactive network retriever.</span><br><span class="line">Usage: wget [OPTION]... [URL]...</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory for short options too.</span><br><span class="line"></span><br><span class="line">Startup:</span><br><span class="line">  -V,  --version           display the version of Wget and exit.</span><br><span class="line">  -h,  --help              print this help.</span><br><span class="line">  -b,  --background        go to background after startup.</span><br><span class="line">  -e,  --execute=COMMAND   execute a `.wgetrc&#x27;-style command.</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>由此可见 <code>wget</code> 的 <code>-e</code> 选项同方法二使用了 http_proxy。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget -e &quot;http_proxy=http://ip:port&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于想使用非全局代理，所以方法三适用。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL FEDERATED 存储引擎介绍及使用</title>
    <url>/2022/02/28/mysql-federated-storage-engine-tutorials/</url>
    <content><![CDATA[<p>项目上遇到了一个需求，需要在 MySQL（不同实例）进行跨库 join 操作。我们都知道如果是同一实例，那么 MySQL 跨库查询肯定是没有问题的，但是不同实例的跨库查询之前一直没有做过。不过以前还在用 Oracle 的时候，Oracle 有个功能叫做 DATABASE LINK（参见 <a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_5005.htm">CREATE DATABASE LINK</a>），是将远程数据库映射到本地，这样就可以在一个实例中访问其他数据库了。在谷歌搜索 MySQL 跨库查询的时候，发现 MySQL 也有类似的东西，叫做 FEDERATED 存储引擎。所以我们就可以使用 FEDERATED 将需要 join 的远端表映射到本地数据库，这样在做查询的时候使用上就跟本地表一样了。</p>
<p>官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/federated-storage-engine.html">The FEDERATED Storage Engine</a></p>
<span id="more"></span>
<h3 id="federated-表介绍"><a class="markdownIt-Anchor" href="#federated-表介绍"></a> FEDERATED 表介绍</h3>
<p>FEDERATED 表在使用上与普通表没有区别，不过 FEDERATED 表只会在本地存储表结构定义而不会直接存储数据，所以在每次查询时数据均需要从远端获取。<br />
FEDERATED 表支持 DML 语句，DDL 语句只支持 <code>DROP TABLE</code>，效果为删除本地的 FEDERATED 表。</p>
<p>官方架构如下：</p>
<img src="/2022/02/28/mysql-federated-storage-engine-tutorials/mysql-federated-storage-engine-tutorials-1.png" class="" title="FEDERATED 架构">
<h3 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h3>
<p>在使用 FEDERATED 表前，需要先看一下是否满足条件：</p>
<ul>
<li>创建 FEDERATED 表的 MySQL 实例需要支持 FEDERATED 引擎，如果是安装的二进制包则没有问题，如果是从源码编译，需要在编译时加上 <code>-DWITH_FEDERATED_STORAGE_ENGINE</code> 参数</li>
<li>创建 FEDERATED 表的 MySQL 实例需要打开 FEDERATED 引擎支持，MySQL 默认没有打开，需要在启动时追加 <code>--federated</code> 命令，或是在配置文件的 <code>[mysqld]</code> 小节添加 <code>federated</code> 并重启服务器。可以在 MySQL 中执行 <code>SHOW ENGINES</code> 语句来查询支持状态</li>
<li>FEDERATED 表支持的远端数据库只能为 MySQL，同时支持 <code>MyISAM</code> 和 <code>InnoDB</code> 存储引擎</li>
<li>经测试，5.7 版本的数据库连接 8.0 版本会报 SSL 错误，所以建议使用 8.0 版本</li>
</ul>
<h3 id="创建-federated-表"><a class="markdownIt-Anchor" href="#创建-federated-表"></a> 创建 FEDERATED 表</h3>
<p>创建 FEDERATED 表有两种方式，但是大同小异，区别只是远端数据库连接是存储在表定义中还是存储到单独的位置。因为 FEDERATED 是表维度，所以为了复用远端连接，建议采用 <code>CREATE SERVER</code> 的方式创建 FEDERATED表。</p>
<h4 id="使用-create-server-的方式创建-federated-表"><a class="markdownIt-Anchor" href="#使用-create-server-的方式创建-federated-表"></a> 使用 CREATE SERVER 的方式创建 FEDERATED 表</h4>
<p>首先我们需要先创建远端数据库连接，创建远端连接的格式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SERVER</span><br><span class="line">server_name</span><br><span class="line"><span class="keyword">FOREIGN</span> DATA WRAPPER wrapper_name</span><br><span class="line">OPTIONS (option [, option] ...)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SERVER fedlink</span><br><span class="line"><span class="keyword">FOREIGN</span> DATA WRAPPER mysql</span><br><span class="line">OPTIONS (<span class="keyword">USER</span> <span class="string">&#x27;fed_user&#x27;</span>, PASSWORD <span class="string">&#x27;password&#x27;</span>, HOST <span class="string">&#x27;remote_host&#x27;</span>, PORT <span class="number">9306</span>, DATABASE <span class="string">&#x27;federated&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>我们需要记住输入的 <code>server_name</code> 即 fedlink，然后我们需要拿到要创建的源表的表结构，可以使用 <code>SHOW CREATE TABLE table_name</code> 来打印，然后将 <code>ENGINE</code> 改为 FEDERATED，添加 <code>CONNECTION='fedlink/table_name'</code>，执行后即在本地生成了 FEDERATED 表。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_table (</span><br><span class="line">    id     <span class="type">INT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    name   <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    other  <span class="type">INT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY  (id),</span><br><span class="line">    INDEX name (name),</span><br><span class="line">    INDEX other_key (other)</span><br><span class="line">)</span><br><span class="line">ENGINE<span class="operator">=</span>FEDERATED</span><br><span class="line"><span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4</span><br><span class="line">CONNECTION<span class="operator">=</span><span class="string">&#x27;fedlink/test_table&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这里创建的表名即 <code>CREATE TABLE</code> 后面的表名可以与源表不一样，只需在 <code>CONNECTION</code> 中指定源表名即可。</p>
<h4 id="使用-connection-的方式创建-federated-表"><a class="markdownIt-Anchor" href="#使用-connection-的方式创建-federated-表"></a> 使用 CONNECTION 的方式创建 FEDERATED 表</h4>
<p>如果没有 <code>CREATE SERVER</code> 权限，也可以直接使用 CONNECTION 的方式创建 FEDERATED 表，只需将上面建表语句中 <code>CONNECTION</code> 的值改为完整连接即可，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> federated_table (</span><br><span class="line">    id     <span class="type">INT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    name   <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    other  <span class="type">INT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY  (id),</span><br><span class="line">    INDEX name (name),</span><br><span class="line">    INDEX other_key (other)</span><br><span class="line">)</span><br><span class="line">ENGINE<span class="operator">=</span>FEDERATED</span><br><span class="line"><span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4</span><br><span class="line">CONNECTION<span class="operator">=</span><span class="string">&#x27;mysql://fed_user@remote_host:9306/federated/test_table&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是：</strong></p>
<ul>
<li>采用这种方式创建的 FEDERATED 表，可以通过 <code>SHOW CREATE TABLE</code> 看到原始的连接信息</li>
<li>如果密码中包含 <code>@</code>，由于 <code>@</code> 需要作为 url 的分界符，所以这种情况下只能使用 <code>CREATE SERVER</code> 的方式创建 FEDERATED 表</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式原理探究</title>
    <url>/2017/04/09/regular-expression/</url>
    <content><![CDATA[<blockquote>
<p>正则表达式是被广为使用的工具，功能非常强大，但语法很复杂，想要完全记忆非常麻烦。<br />
偶然间在《算法：第四版》上看到了有关于正则表达式原理的叙述，受益匪浅，在此做下笔记。</p>
</blockquote>
<h1 id="正则表达式的定义"><a class="markdownIt-Anchor" href="#正则表达式的定义"></a> 正则表达式的定义</h1>
<p>**什么是正则表达式？**一个正则表达式对应着一堆字符串，这些字符串构成一个集合，它们的共同特点就是匹配于这个正则表达式。例如：a(a|b) * b 就对应着第一个字符为a，最后一个字符为b，由a和b构成的字符串。</p>
<p>正则表达式有三种核心的基本结构：</p>
<ol>
<li><em>连接</em>：如 abc，由 a, b, c连接而成。</li>
<li><em>或</em>：如 a|b|c，表示是 a 或 b 或 c。<br />
ab|bcd表示ab或bcd。</li>
<li><em>闭包</em>：如a*b，表示0或若干个a和一个b连接而成的字符串。</li>
</ol>
<p>以上就是最最最基本的结构，是构成正则表达式的基础。</p>
<span id="more"></span>
<p>我们可以使用括号改变优先级顺序，如 c(ac|b)d 表示 cacd, cbd。</p>
<p>至于其它教程里写到的如 +,?, [] 等操作都是基本操作的简略缩写，它们都可以通过基本操作完成。</p>
<p>+ 是由那些基本操作完成的？(文章末尾给出答案)</p>
<p>基本的语法就介绍到这，这篇文章并不是主要讲应用。有兴趣朋友可以在网上搜索完整的语法规则，非常详细。</p>
<h1 id="非确定有限状态自动机"><a class="markdownIt-Anchor" href="#非确定有限状态自动机"></a> 非确定有限状态自动机</h1>
<h2 id="dfa"><a class="markdownIt-Anchor" href="#dfa"></a> DFA</h2>
<p>DFA 又叫确定有限状态自动机，即对于一个输入，它的输出状态是确定的。如图：</p>
<img src="/2017/04/09/regular-expression/regular-expression-1.png" class="">
<p>对于这个自动机，输出边是 Turn On 和 Turn Off 的动作，Turn On 导致状态变为 On，Turn Off 导致状态变为 Off。<br />
这两个动作所导致的结果是可以预料的，确定的。所以说是确定有限状态自动机。</p>
<h2 id="nfa"><a class="markdownIt-Anchor" href="#nfa"></a> NFA</h2>
<p>NFA 叫非确定有限状态自动机，和 DFA 的唯一区别是它的输出是非确定的，DFA是NFA的一个子集。如图：</p>
<img src="/2017/04/09/regular-expression/regular-expression-2.png" class="">
<p>还是那个例子，只不过状态 Off 的 Turn On 操作多了一个新的状态 Down</p>
<p>当我们进行 Turn On 操作时无法确定到达的是 On 还是 Down，因此是无法根据当前状态和输出边确定下一状态的，这就叫做非确定性有限状态自动机。</p>
<h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2>
<p>我们先来看一个示例，它说明了 NFA 的性质和操作。如图：</p>
<img src="/2017/04/09/regular-expression/regular-expression-3.png" class="">
<p>（图表示((A*B|AC)D)所对应的 NFA）</p>
<p>我们定义的NFA有以下特点：</p>
<ol>
<li>正则表达式中每个字符有且只有一个对应的状态。</li>
<li>字符所对应的状态有一条指向下一个字符对应状态的边（图中黑色的边）</li>
<li>“(”,  “)”, “|”, 和&quot;*&quot;所对应的状态至少含有一条指出的边，可能指向任意状态（图中红色边）</li>
<li>一个状态只能有一条指出的黑色边</li>
</ol>
<p>我们用构造的NFA去匹配文本，当从起始状态0能够到达最终状态的话，即匹配成功，这就是正则表达式匹配文本的原理。</p>
<p>NFA中状态的转换有以下两种:</p>
<ol>
<li>匹配转换： 当字符匹配时，由黑色的边转换到下一状态。</li>
<li>ε-转换：不扫描任何字符，通过红色的边转换到另一个状态。</li>
</ol>
<h2 id="nfa-的运行"><a class="markdownIt-Anchor" href="#nfa-的运行"></a> NFA 的运行</h2>
<p>运行的核心思想就是：遍历所有可能到达的状态序列，只要其中存在最终状态就匹配成功。类似于动态规划。</p>
<p>首先将NFA中的两个状态转换表示出来。我们用一个char数组re[]保存正则表达式本身 ，如果re[i]存在于字母表中，那么就存在一个从i到i+1的匹配转换。</p>
<p>自然地，ε- 转换就用有向图G表示，实例中的 ε-转换可构建为: 0-&gt;1  1-&gt;2   1-&gt;6    2-&gt;3…以此类推。</p>
<p>当处于状态 0 时，我们遍历所有从0通过ε-转换(有向图的深度优先搜索)可到达的状态放入一个集合，再从中查找是否存在最终状态的值。<br />
当匹配一个字符到达状态1后，再遍历所有从1通过ε-转换可到达的状态…如此反复，当文本结束时从集合中找到是否含有最终状态来说明是否到达接受状态。</p>
<p>例如，在实例中初始集合为{1, 2, 3, 4, 6}，如果第一个字符为A，则接下来可能的状态为 {3, 7} ,通过 ε- 转换可到 2，4，因此第二个字符状态集合为 {2, 3, 4, 7}。再不断重复这个过程直到文本结束。</p>
<p>输入A A B D会有什么样的轨迹？(文章末尾给出答案)</p>
<h2 id="nfa-的构造"><a class="markdownIt-Anchor" href="#nfa-的构造"></a> NFA 的构造</h2>
<p>长串的正则表达式都是三个基本操作和括号构成的，因此我们的NFA也可以看作成若干基本操作拼接而成，下面就来介绍一下基本操作所对应的 NFA。</p>
<ol>
<li>
<p>连接操作：字符加状态匹配即可。</p>
<img src="/2017/04/09/regular-expression/regular-expression-4.png" class="">
</li>
<li>
<p>括号：用栈处理。</p>
</li>
<li>
<p>闭包操作：</p>
<ul>
<li>
<p>出现在单个字符之后：在该字符和 * 之间添加两条 ε- 转换。</p>
<img src="/2017/04/09/regular-expression/regular-expression-5.png" class="">
</li>
<li>
<p>出现在右括号之后：在栈顶的左括号和 * 之间添加两条 ε- 转换。</p>
<img src="/2017/04/09/regular-expression/regular-expression-6.png" class="">
</li>
</ul>
</li>
<li>
<p>或：A|B中A和B都是正则表达式。同样也是添加两条ε-转换，一条从左括号指向<br />
B中第一个字符，另一条从|字符指向右括号。这使NFA能够进行选择。<img src="/2017/04/09/regular-expression/regular-expression-7.png" class=""></p>
</li>
</ol>
<p>运用以上几个基本的 NFA，我们可以拼接出任意 NFA。</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<p>本篇文章以介绍概念为主，具体的实现可参照<a href="http://algs4.cs.princeton.edu/54regexp/NFA.java.html">NFA.java</a></p>
<h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1>
<h2 id="感想"><a class="markdownIt-Anchor" href="#感想"></a> 感想</h2>
<blockquote>
<p>正则表达式是很强大的工具，网上教程一大把，但多数是直接告诉你语法，基本没规律，只能强记，效率略低。<br />
明白原理后，不仅记忆深刻，而且还可以编写适合自己的规则。<br />
（其实说到底都是《编译原理》课程上的东西，无奈学校不开😤好气哦）</p>
</blockquote>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<ol>
<li>《算法：第4版》</li>
</ol>
<h3 id="答案"><a class="markdownIt-Anchor" href="#答案"></a> 答案</h3>
<ol>
<li>+ : (ab)+ 等价于 (ab)(ab)*</li>
<li>{0, 1, 2, 3, 4, 6} -&gt; {2, 3, 4, 7} -&gt; {2, 3, 4} -&gt; {5, 8, 9} -&gt; {10}</li>
</ol>
]]></content>
      <categories>
        <category>Regular Expression</category>
      </categories>
      <tags>
        <tag>Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title>修复 Sharding-JDBC 使用时的两次 NoClassDefFoundError</title>
    <url>/2022/03/01/resolve-class-not-found-in-sharding-jdbc/</url>
    <content><![CDATA[<p>由于项目上有着某些需求，所以需要使用 Sharding-JDBC。根据官方文档，引入 <code>shardingsphere-jdbc-core</code> 依赖并使用当前最新版本 5.1.0，结果在测试的过程中出现了两次 NoClassDefFoundError，分别记录一下解决过程。</p>
<span id="more"></span>
<h3 id="一-classnotfoundexception-orgapachetomcatdbcpdbcp2basicdatasource"><a class="markdownIt-Anchor" href="#一-classnotfoundexception-orgapachetomcatdbcpdbcp2basicdatasource"></a> 一、ClassNotFoundException: org.apache.tomcat.dbcp.dbcp2.BasicDataSource</h3>
<p>配置完程序，兴冲冲地打开前端准备测试，可没想到刚打开就报了个错。老规矩，先看最后一个 Caused by，结果是个没头没脑的 ClassNotFoundException。</p>
<img src="/2022/03/01/resolve-class-not-found-in-sharding-jdbc/resolve-class-not-found-in-sharding-jdbc-1.png" class="" title="报错信息">
<p>那就继续往上翻，看一下异常栈信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: org/apache/tomcat/dbcp/dbcp2/BasicDataSource</span><br><span class="line">	at org.apache.shardingsphere.infra.datasource.pool.metadata.type.dbcp.TomcatDBCPDataSourcePoolMetaData.getType(TomcatDBCPDataSourcePoolMetaData.java:67)</span><br><span class="line">	at org.apache.shardingsphere.spi.typed.TypedSPIRegistry.lambda$findRegisteredService$0(TypedSPIRegistry.java:44)</span><br><span class="line">	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:174)</span><br><span class="line">	at java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1361)</span><br><span class="line">	at java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:126)</span><br><span class="line">	at java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:499)</span><br><span class="line">	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:486)</span><br><span class="line">	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)</span><br><span class="line">	at java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:152)</span><br><span class="line">	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)</span><br><span class="line">	at java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:531)</span><br><span class="line">	at org.apache.shardingsphere.spi.typed.TypedSPIRegistry.findRegisteredService(TypedSPIRegistry.java:44)</span><br><span class="line">	at org.apache.shardingsphere.infra.datasource.pool.metadata.DataSourcePoolMetaDataFactory.newInstance(DataSourcePoolMetaDataFactory.java:46)</span><br><span class="line">	at org.apache.shardingsphere.infra.datasource.props.DataSourcePropertiesCreator.createProperties(DataSourcePropertiesCreator.java:81)</span><br><span class="line">	at org.apache.shardingsphere.infra.datasource.props.DataSourcePropertiesCreator.create(DataSourcePropertiesCreator.java:57)</span><br><span class="line">	at org.apache.shardingsphere.infra.metadata.resource.DataSourcesMetaData.&lt;init&gt;(DataSourcesMetaData.java:41)</span><br><span class="line">	at org.apache.shardingsphere.infra.metadata.ShardingSphereMetaData.createResource(ShardingSphereMetaData.java:73)</span><br><span class="line">	at org.apache.shardingsphere.infra.metadata.ShardingSphereMetaData.create(ShardingSphereMetaData.java:66)</span><br><span class="line">	at org.apache.shardingsphere.mode.metadata.MetaDataContextsBuilder.getMetaDataMap(MetaDataContextsBuilder.java:105)</span><br><span class="line">	at org.apache.shardingsphere.mode.metadata.MetaDataContextsBuilder.build(MetaDataContextsBuilder.java:96)</span><br><span class="line">	at org.apache.shardingsphere.mode.manager.memory.MemoryContextManagerBuilder.build(MemoryContextManagerBuilder.java:49)</span><br><span class="line">	at org.apache.shardingsphere.driver.jdbc.core.datasource.ShardingSphereDataSource.createContextManager(ShardingSphereDataSource.java:81)</span><br><span class="line">	at org.apache.shardingsphere.driver.jdbc.core.datasource.ShardingSphereDataSource.&lt;init&gt;(ShardingSphereDataSource.java:64)</span><br><span class="line">	at org.apache.shardingsphere.driver.api.ShardingSphereDataSourceFactory.createDataSource(ShardingSphereDataSourceFactory.java:77)</span><br></pre></td></tr></table></figure>
<p>首先点进去看一下第一行的 <code>TomcatDBCPDataSourcePoolMetaData</code> 这个类，IDE 很明显地提示了错误，所以根源在于 Sharding 使用了 <code>BasicDataSource</code> 类却没有引入其依赖。</p>
<img src="/2022/03/01/resolve-class-not-found-in-sharding-jdbc/resolve-class-not-found-in-sharding-jdbc-2.png" class="" title="IDE 报红">
<p>既然问题的根源找到了，那么接下来看一眼为什么会触发到这里。</p>
<p>接着看第二行，<code>TypedSPIRegistry</code> 类的 44 行，并在这里下一个断点：</p>
<img src="/2022/03/01/resolve-class-not-found-in-sharding-jdbc/resolve-class-not-found-in-sharding-jdbc-3.png" class="" title="打下断点">
<img src="/2022/03/01/resolve-class-not-found-in-sharding-jdbc/resolve-class-not-found-in-sharding-jdbc-4.png" class="" title="断点暂停">
<img src="/2022/03/01/resolve-class-not-found-in-sharding-jdbc/resolve-class-not-found-in-sharding-jdbc-5.png" class="" title="运行表达式">
<p>可以看到，<code>ShardingSphereServiceLoader.newServiceInstances(typedSPIClass)</code> 方法传入了 SPI 类 <code>DataSourcePoolMetaData</code>， 并获取到了其三个实现类，而最后一个 <code>TomcatDBCPDataSourcePoolMetaData</code> 类就是刚才抛出异常的类。</p>
<img src="/2022/03/01/resolve-class-not-found-in-sharding-jdbc/resolve-class-not-found-in-sharding-jdbc-6.png" class="" title="DataSourcePoolMetaData 实现类">
<p>然后在后续的 <code>filter</code> 中，会循环每个对象，在调用 <code>getType()</code> 方法时便出现了异常。</p>
<p>所以看上去并不是自己的问题，在谷歌之后发现，近期已经有人提出了这个问题，具体可以参见：<a href="https://github.com/apache/shardingsphere/issues/15507">Add example that implements the Metadata SPI for third-party JDBC pools</a>。</p>
<p>通过 issue 中的描述我们可以得知，这个问题是在 5.1.0 中才出现的。看上去已经有人提了 PR 修复了这个问题，但是目前还没有发布新版本。所以我们可以降级到 5.0.0 使用旧版本来规避这个问题，或者直接引入缺失的依赖使代码不再报错。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-dbcp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>10.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="二-noclassdeffounderror-organtlrv4runtimecodepointbuffer"><a class="markdownIt-Anchor" href="#二-noclassdeffounderror-organtlrv4runtimecodepointbuffer"></a> 二、NoClassDefFoundError: org/antlr/v4/runtime/CodePointBuffer</h3>
<p>修复好刚才的问题之后，重新运行程序，创建数据源，好，没有报错。再执行一下 SQL 查询，不好，又报错了…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: org/antlr/v4/runtime/CodePointBuffer</span><br><span class="line">	at org.apache.shardingsphere.sql.parser.core.SQLParserFactory.getSQLCharStream(SQLParserFactory.java:82)</span><br><span class="line">	at org.apache.shardingsphere.sql.parser.core.SQLParserFactory.createTokenStream(SQLParserFactory.java:76)</span><br><span class="line">	at org.apache.shardingsphere.sql.parser.core.SQLParserFactory.newInstance(SQLParserFactory.java:55)</span><br><span class="line">	at org.apache.shardingsphere.sql.parser.core.database.parser.SQLParserExecutor.twoPhaseParse(SQLParserExecutor.java:58)</span><br><span class="line">	at org.apache.shardingsphere.sql.parser.core.database.parser.SQLParserExecutor.parse(SQLParserExecutor.java:49)</span><br><span class="line">	at org.apache.shardingsphere.sql.parser.api.SQLParserEngine.parse(SQLParserEngine.java:47)</span><br><span class="line">	at org.apache.shardingsphere.infra.parser.sql.SQLStatementParserExecutor.parse(SQLStatementParserExecutor.java:48)</span><br><span class="line">	at org.apache.shardingsphere.infra.parser.sql.SQLStatementParserEngine.parse(SQLStatementParserEngine.java:47)</span><br><span class="line">	at org.apache.shardingsphere.infra.parser.ShardingSphereSQLParserEngine.parse0(ShardingSphereSQLParserEngine.java:70)</span><br><span class="line">	at org.apache.shardingsphere.infra.parser.ShardingSphereSQLParserEngine.parse(ShardingSphereSQLParserEngine.java:59)</span><br><span class="line">	at org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSphereStatement.createLogicSQL(ShardingSphereStatement.java:414)</span><br><span class="line">	at org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSphereStatement.executeQuery(ShardingSphereStatement.java:144)</span><br><span class="line">	at org.springframework.jdbc.core.JdbcTemplate$1QueryStatementCallback.doInStatement(JdbcTemplate.java:452)</span><br><span class="line">	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:381)</span><br><span class="line">	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:465)</span><br><span class="line">	at org.springframework.jdbc.core.JdbcTemplate.queryForRowSet(JdbcTemplate.java:530)</span><br></pre></td></tr></table></figure>
<p>从第一行点进去先看眼，又是找不到类，不过这次不太一样。看下上面的 import，发现这个包下的大部分的类都可以找到，只有这两个没有找到：</p>
<img src="/2022/03/01/resolve-class-not-found-in-sharding-jdbc/resolve-class-not-found-in-sharding-jdbc-7.png" class="" title="import 信息">
<p>只能盲猜是版本问题，打开 Maven Helper 看一下依赖情况，果然是和公司自己的包发生了版本冲突。手动指定版本到 4.9.2，问题解决。</p>
<img src="/2022/03/01/resolve-class-not-found-in-sharding-jdbc/resolve-class-not-found-in-sharding-jdbc-8.png" class="" title="import 信息">
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Sharding</tag>
        <tag>Sharding-JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Ubuntu 22.04 下安装 Rancher 出现与 Docker 不兼容的问题</title>
    <url>/2022/06/11/resolve-install-rancher-error-on-ubuntu-2204/</url>
    <content><![CDATA[<p>好不容易开到了 Oracle 的 Arm 机器，因为内存还是比较多的，所以打算用 Rancher 安装 k8s 使用。由于以前在生产环境使用 Ubuntu 安装过 Rancher，所以直接上手，可没想到这次一路波折。 因为 CentOS 8 已经停止维护了，Oracle 上面 CentOS 的镜像也更新成为了 CentOS Stream，加上也不太想用 Oracle Linux，所以直接开了最新的 Ubuntu 22.04，噩梦开始的地方。</p>
<span id="more"></span>
<p>最开始还是采用 Docker 的方式安装 Rancher，结果发现 Rancher 容器不断重启。查询日志后发现，在打印一些日志之后，每次都会出现 <code>k3s exited with: exit status 1</code> 错误。 由于之前的生产环境是 Ubuntu 20.04，而且 Rancher 官网并没有严格的操作系统支持说明，所以首先还是怀疑是系统问题。但是由于 Oracle Cloud 并没有提供重装系统功能，如果想初始化就只能删除重开机器。 加上 Arm 机器众所周知的原因，所以不敢冒险尝试删除重建机器。不过既然报错是 k3s 初始化失败，那么就自行安装 k3s 试一下，看一下具体的报错问题。k3s 安装过程果然报错， 输入 <code>journalctl -xeu k3s.service</code> 查看一下报错详情：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to get unit file state for nm-cloud-setup.service: No such file or directory</span><br></pre></td></tr></table></figure>
<p>看来是 Oracle 安装的 Ubuntu 没有自带网络服务，安装之后再试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install network-manager</span><br></pre></td></tr></table></figure>
<p>发现还是报错，再来看一眼报错详情：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to run kubelet&quot; err=&quot;failed to run Kubelet: misconfiguration: kubelet cgroup driver: \&quot;cgroupfs\&quot; is different from docker cgroup driver: \&quot;systemd\&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>这下问题就清楚了，原来 k8s 默认使用的 cgroup 是 <code>cgroupfs</code>，而 Docker 所使用的 cgroup 是 <code>systemd</code>，两者不一致。执行 <code>docker info</code> 我们也确实可以看到 <code>Cgroup Driver: systemd</code>。 搜寻了一下发现解决办法也很简单，要么指定 k8s 使用 <code>systemd</code> 的 cgroup，要么设置 Docker 使用 <code>cgroupfs</code>。由于 k3s 是自行初始化的，加之在安装 Rancher 的时候并没有给我们设置 k3s 的地方， 所以只能修改 Docker 的 cgroup 为 <code>cgroupfs</code>。</p>
<p>创建或修改 <code>/etc/docker/daemon.json</code> 文件，添加如下内容后重启 docker：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=cgroupfs&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次执行 <code>docker info</code> 我们可以看到 cgroup 已经修改生效了：<code>Cgroup Driver: cgroupfs</code>。</p>
<p>重启 k3s，发现 k3s 已经可以成功启动了。然后执行 <code>/usr/local/bin/k3s-uninstall.sh</code> 卸载 k3s，再安装一遍 rancher 来看一下。 结果发现还是在报错，这就很奇怪了，明明自己安装 k3s 是没有问题的了。 无奈只能去求助 Google，虽然看到了很多类似问题，但是一直未找到有效回复。 一番搜索后，发现 GitHub 上有个 Issue：<a href="https://github.com/rancher/rancher/issues/35201">k3s exited with: exit status 1</a>。 虽然他是使用的 Debian 11，日志多打印出来了很多，不过最终的报错都是一样的。而且更重要的是，他所贴出的 docker 信息表名他 docker 的 cgroup 也是 <code>systemd</code>。 然后发现仅有的一条来自贡献者的回复成为了关键，他说 Debian 11 默认使用 cgroup v2，这与 k3s 并不兼容，需要将其切换到 cgroup v1。 好家伙，原来 cgroup 还有版本的问题，看来我们也要将 cgroup 切换到 v1。 在 Docker 的官方文档中找到了切换的方法：<a href="https://docs.docker.com/config/containers/runmetrics/#changing-cgroup-version">Changing cgroup version</a>。 因为 Ubuntu 没有自带 <code>grubby</code> 命令，所以采用的是第二种手动修改 grub 引导文件的方式。</p>
<p>执行 <code>sudo vi /etc/default/grub</code>，添加 <code>systemd.unified_cgroup_hierarchy=0</code> 到 <code>GRUB_CMDLINE_LINUX</code> 参数中，如果原来有内容记得保留，空格分割。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX=&quot;systemd.unified_cgroup_hierarchy=0&quot;</span><br></pre></td></tr></table></figure>
<p>然后执行 <code>sudo update-grub</code> 更新下引导，重启之后发现 Rancher 可以正常安装了。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Kubernetes</tag>
        <tag>K8s</tag>
        <tag>K3s</tag>
        <tag>Rancher</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】Hibernate 软删除：你可能忽略掉的一些东西</title>
    <url>/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/</url>
    <content><![CDATA[<img src="/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/soft-deletion-in-hibernate-things-you-may-miss-1.png" class="">
<p>我们在设计生产系统的时候，无论是为了方便恢复、便于查找问题还是审计等，总是绕不开软删除这个话题。国内互联网公司大部分均使用 MyBatis 作为 ORM 框架，所以大部分的资料也都是 MyBatis 的各种软删除实现，用起来也都没什么问题。但是手里项目使用的是 Hibernate，虽然 Hibernate 也可以找到很多软删除的方案，当初最开始参考的也是原文列出的第一个 Baeldung 网站的方案，但是由于 Hibernate 大部分时候都是直接对实体进行操作，所以软删除用起来会遇到很多的问题。比如自己就遇到了软删除 + 二级缓存冲突的问题，先抛开这个不谈，毕竟在权衡之下直接关闭二级缓存就解决了问题，在基本使用时软删除也不可避免地会遇到各种问题。正好偶然看到了 JPA Buddy 上一篇文章在说这个问题，索性简单翻译下，希望大家在设计软删除方案的时候能够进行充分的考虑。</p>
<p>原文：<a href="https://www.jpa-buddy.com/blog/soft-deletion-in-hibernate-things-you-may-miss/">Soft Deletion in Hibernate: Things You May Miss</a></p>
<span id="more"></span>
<hr />
<p>软删除是一种广泛使用的模式，简单来说就是：你仅仅将实体标记为删除状态并通过在 SELECT 查询中过滤他们而不是物理删除这些实体。使用软删除有很多常见的原因：审计、可恢复性、或者可以很方便地在将数据伪造成删除状态的同时保持着对这些“已删除”记录的引用。</p>
<p>在这篇文章中我们将关注一些大部分讲述软删除方案的文章所未提到的细节。</p>
<h4 id="sqldelete-where"><a class="markdownIt-Anchor" href="#sqldelete-where"></a> @SQLDelete + @Where</h4>
<p>如果你以“soft deletion hibernate”为关键词在谷歌上进行搜索的话，你很可能找到 <a href="https://www.baeldung.com/spring-jpa-soft-delete">Eugen Paraschiv</a>、<a href="https://vladmihalcea.com/the-best-way-to-soft-delete-with-hibernate/">Vlad Mihalcea</a> 或是 <a href="https://thorben-janssen.com/implement-soft-delete-hibernate/">Thorben Janssen</a> 写的教程。他们都建议使用 Hibernate 的 <code>@SQLDelete</code> 和 <code>@Where</code> 注解来让程序自动设置删除标识并可以在查询时自动过滤这些数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;article&quot;)</span></span><br><span class="line"><span class="meta">@SQLDelete(sql = &quot;update article set deleted=true where id=?&quot;)</span></span><br><span class="line"><span class="meta">@Where(clause = &quot;deleted = false&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy = GenerationType.SEQUENCE)</span></span><br><span class="line">   <span class="meta">@Column(name = &quot;id&quot;, nullable = false)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column(name = &quot;deleted&quot;, nullable = false)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">deleted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// other properties, getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@SQLDelete</code> 注解会在 Hibernate 管理的对象被删除时执行我们设定好的原生 SQL 语句。<code>@Where</code> 注解通过将自身的查询条件自动追加到 SELECT 查询语句中来帮你自动过滤掉这些被标记为删除的数据。</p>
<p>这个方法看上去是一剂良药，但是里面有坑。普通查询肯定可以正常工作，但是如果是关联查询呢？</p>
<h4 id="关联查询所遇到的问题"><a class="markdownIt-Anchor" href="#关联查询所遇到的问题"></a> 关联查询所遇到的问题</h4>
<p>让我们仔细思考一下，假设你拥有一个实体，里面可能关联了另一个实体的集合，或者仅仅是另一个实体对象，但相同的是他们均被软删除。当你获取到这个实体对象时，你期望发生什么？实际上，这里没有几个选项可供选择：被删除的记录呈现或者不呈现在查询结果中，而不同的选择取决于不同的场景用例。比如，我们在商城购物车中有很多的商品，当一件商品被删除时我们期望其从购物车中消失对吧？但是被删除的商品仍应该出现在历史账单中，这难道不矛盾嘛？</p>
<p>让我们来看一下 <code>@SQLDelete</code> 和 <code>@Where</code> 注解在不同类型的关联关系、FetchType 和不同的查询 API 中是怎样工作的。下面是我们将要在后续实验中使用的 ER 图：</p>
<img src="/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/soft-deletion-in-hibernate-things-you-may-miss-2.png" class="" title="ER 图">
<p>Article 和 Author 拥有多对多关系，和 Comment 有着一对多关系，以及和 ArticleDetails 有着一对一的关系。那么问题来了，他们中的某一个在被其他实体引用时被软删除会发生什么？</p>
<h4 id="onetomany-manytomany"><a class="markdownIt-Anchor" href="#onetomany-manytomany"></a> OneToMany &amp; ManyToMany</h4>
<p>Hibernate 会自动在所有对多关系中过滤掉被删除的实体。如果你在删除一个 Author 之前和之后分别运行下面的代码，打印出的 Author 的名字数量会发生变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Article&gt; articleOptional = articleRepository.findById(<span class="number">4L</span>);</span><br><span class="line">articleOptional.ifPresent(article -&gt; &#123;</span><br><span class="line">   article.getAuthors()</span><br><span class="line">           .forEach(author -&gt; logger.info(author.getName()));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>好消息是，无论 FetchType 的值是什么或者用哪种查询方式（比如 entityManager、Criteria API、Spring Data JPA 等），上述结果都成立。</p>
<h4 id="懒加载下的-manytoone-onetoone"><a class="markdownIt-Anchor" href="#懒加载下的-manytoone-onetoone"></a> 懒加载下的 ManyToOne &amp; OneToOne</h4>
<p>让我们试着想象一下我们软删除了一篇文章，但我们不希望删除这篇文章下面的评论，因为这样在恢复文章时评论也会自动恢复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;comment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comment</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">   <span class="meta">@JoinColumn(name = &quot;article_id&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> Article article;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，让我们尝试获取一条对应文章被删除的评论：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Comment&gt; comment = commentRepository.findById(id);</span><br><span class="line">comment.ifPresent(com -&gt; logger.info(com.getArticle().getText()));</span><br></pre></td></tr></table></figure>
<p>如果你在第一行打一个断点，你可以看到 article 属性的值是 Hibernate Proxy 对象。</p>
<img src="/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/soft-deletion-in-hibernate-things-you-may-miss-3.png" class="" title="debug">
<p>这很容易理解，因为 Hibernate 并不能提前知道这个实体是否已经被删除。但是当我们执行 <code>com.getArticle().getText()</code> 方法时，却抛出了 EntityNotFoundException 异常，这是你所期望的吗？</p>
<h4 id="提前加载下的-manytoone-onetoone"><a class="markdownIt-Anchor" href="#提前加载下的-manytoone-onetoone"></a> 提前加载下的 ManyToOne &amp; OneToOne</h4>
<p>让我们将 FetchType 的值改为 EAGER 后再次重复相同的实验。现在我们在程序不使用代理的情况下获取到了关联的 article 对象，虽然 Hibernate 知道 article 已经被删除了。让我们进行同样的测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Comment&gt; comment = commentRepository.findById(id);</span><br><span class="line">comment.ifPresent(com -&gt; logger.info(com.getArticle().getText()));</span><br></pre></td></tr></table></figure>
<p>被关联查询且被软删除的 article 对象在没有报任何异常的情况下被加载了，其软删除标志为也依然为 <code>true</code>：</p>
<img src="/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/soft-deletion-in-hibernate-things-you-may-miss-4.png" class="" title="debug">
<p>这种不一致的行为很容易被解释，提前加载让 Hibernate 查询时 join 了 <code>article</code> 表。Hibernate 面临着立即抛出 EntityNotFoundException 异常还是正常加载的抉择，但因为 article 已经被加载了，<code>@Where</code> 注解失去了它的作用，所以 Hibernate 只是简单地为对象赋了值。</p>
<p>现在让我们批量查询 comments：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterable&lt;Comment&gt; comments = commentRepository.findAll();</span><br></pre></td></tr></table></figure>
<p>现在我们又遇到了 EntityNotFoundException 异常！出现异常是因为 <code>findAll</code> 方法分离查询被关联的 Article 对象，详情可以参考 <a href="https://stackoverflow.com/questions/49192255/spring-data-findall-does-not-fetch-eagerly/49193254">Spring data findAll() does not fetch eagerly</a>。</p>
<p>任何时候被软删除的对象在被使用分离查询时都会导致上面的异常，因为 Hibernate 在生成分离查询时应用了 <code>@Where</code> 所定义的条件，所以很显然 Hibernate 并不能查询到被软删除的实体。所以很显然，这种查询并不能查到 Hibernate 所期望的结果，所以在这种情况下导致了 EntityNotFoundException 异常。</p>
<p>所以更有趣的是你需要进行很多实验来认识到 Hibernate 在使用不同的 API 时是怎样获取数据的。首先，无论是对多还是对一的实体，在使用 DSL 查询时你均会遇到同样的异常。与此同时，criteria API 会在提前加载的一对一关系下返回被删除的实体，但会在提前加载的多对一关系中抛出 EntityNotFoundException 异常。这难道不令人困惑吗？</p>
<h4 id="避免-entitynotfoundexception-异常的解决方式"><a class="markdownIt-Anchor" href="#避免-entitynotfoundexception-异常的解决方式"></a> 避免 EntityNotFoundException 异常的解决方式</h4>
<p>这里有一个可以避免 EntityNotFoundException 异常的解决方法。Hibernate <a href="https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#associations-not-found">介绍</a>了 <code>@NotFound</code> 注解，它能够让程序不再抛出异常，而是直接将关联对象的值设置为 <code>null</code>。</p>
<p>这个解决办法看起来是一个灵丹妙药，但它同时带来了额外的缺点：无论 FetchType 设置为什么，所有的对一关系均会提前加载。</p>
<img src="/2022/01/07/soft-deletion-in-hibernate-things-you-may-miss/soft-deletion-in-hibernate-things-you-may-miss-5.png" class="" title="官网介绍">
<h4 id="约束和索引带来的问题"><a class="markdownIt-Anchor" href="#约束和索引带来的问题"></a> 约束和索引带来的问题</h4>
<p>我们知道被软删除的实体和正常的实体均会被唯一约束和索引所限制，因此，常规的索引在这种情况下不再适用。假设一个 Author 实体的 login 字段有唯一约束，在软删除表中已有的记录后，记录仍然存在，所以正常状态的 Author 实体的同样的字段也不能再被设置为被软删除的相同的值。</p>
<p>如果你正在使用 PostgreSQL，那么你很幸运，因为你可以使用部分索引：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX author_login_idx ON <span class="title function_">author</span> <span class="params">(login)</span> <span class="type">WHERE</span> <span class="variable">deleted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>但如果你使用的是 MySQL，那么很不幸，这个问题无解。</p>
<h4 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h4>
<p>所以你可以看到，软删除是一个很容易被理解但不容易去实现的模式。看上去现在还没有一个完美的解决方案，至少 Hibernate 现阶段还没有提供。</p>
<p>在一些简单的场景，你确实可以直接采用使用 <code>@SQLDelete</code> + <code>@Where</code> 注解的方式，但在软删除实体出现在一对一或者多对一关联关系的时候，你并不能期望他们行为一致。只是简单地改变 FetchType 的值，或是使用 <code>@EntityGraph</code>，或者将你的查询从 Criteria API 迁移到 DSL 查询，或是其他任何改变都很可能影响查询结果：从被意外抛出异常到意外地成功加载了被删除的实体，或是直接获得了意料之外的 <code>null</code> 值。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>波浪排序</title>
    <url>/2022/03/03/sort-an-array-in-a-waveform/</url>
    <content><![CDATA[<p>偶然间看到了一道算法题，第一眼看起来还挺简单，但是想了想发现不止这么简单，应该会有更优解。拿“波浪排序”作为关键字在百度上进行搜索，发现并没有相关题目。又以“sort wave”为关键字在谷歌上进行搜索，终于发现了相关解析，这里用自己的方式记录一下解题思路。</p>
<p>首先来看题目：</p>
<blockquote>
<p>将给定的数组中的元素进行波浪形排序，输出任意正确结果。<br />
波浪形排序是指: arr[0] ≥ arr[1] ≤ arr[2] ≥ arr[3] ≤ arr[4] ≥ arr[5]<br />
例如:<br />
输入: 1, 2, 6, 7, 5, 3, 4<br />
输出: 4, 1, 7, 5, 6, 2, 3</p>
</blockquote>
<p>解法参考：<a href="https://www.enjoyalgorithms.com/blog/sort-an-array-in-a-waveform">Sort an array in a waveform</a></p>
<span id="more"></span>
<h3 id="一-排序解法"><a class="markdownIt-Anchor" href="#一-排序解法"></a> 一、排序解法</h3>
<p>排序解法是最简单也是最容易想到的解法。首先对数组进行排序，升序降序不重要，因为解法有很多种。</p>
<p>排序后我们可以：</p>
<ul>
<li>从两端分别拿取最大值和最小值，逐渐完成排序</li>
<li>算出数组中间元素，则将整个数组划分为了小半区和大半区，然后同样分别往两端拿取各半区元素，完成排序</li>
<li>升序排序后，偶数位（非数组下标位）的元素一定会大于等于前面的元素，将偶数位元素分别与前面的元素交换</li>
</ul>
<p>因为第三种解法不需要额外的空间占用，所以我们主要关注第三种解法。</p>
<h4 id="图解"><a class="markdownIt-Anchor" href="#图解"></a> 图解</h4>
<p>把参考链接里面现成的图拿过来方便理解。</p>
<p>对原数组进行排序：</p>
<img src="/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-1.png" class="" title="排序后">
<p>然后分别交换偶数位及前面的元素：</p>
<img src="/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-2.png" class="" title="交换元素后">
<h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">        tmp = arr[i - <span class="number">1</span>];</span><br><span class="line">        arr[i - <span class="number">1</span>] = arr[i];</span><br><span class="line">        arr[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析</h4>
<p>排序后再遍历处理的时间复杂度为排序的时间复杂度 + 后续遍历处理时间复杂度，最优为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度仍然取决于使用的排序算法 + 后续处理是否需要占用空间，最优为：堆排 + 交换解法 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h3 id="二-一次遍历解决"><a class="markdownIt-Anchor" href="#二-一次遍历解决"></a> 二、一次遍历解决</h3>
<p>这道题的最优解在于，我们能否不使用排序，仅使用一次遍历完成波浪排序。</p>
<p>从上面的结果可以看出，符合要求的答案，偶数位的元素，一定小于等于其前面和其后面的元素（对应题目要求的 arr[0] ≥ arr[1] ≤ arr[2]、arr[2] ≥ arr[3] ≤ arr[4]）。所以我们可以认为，对于每个偶数位元素，其一定是与相邻两个的元素比较中的最小值。那么我们就遍历偶数位元素，与其相邻元素为一组，将其交换为组内的最小值。然后我们可以看到，划分并遍历元素组的时候，遍历步长为 2，而元素为 3 个一组，所以奇数位元素会参与两次比较交换。<br />
画了个图便于理解，数字是排序完的一个结果，看上去直观一点：</p>
<img src="/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-3.png" class="" title="对元素分组">
<p>所以我们还需要解决的问题就是，当一次交换后，比如上图中的 30-10-50 排列好后，在以 20 为中心进行分组交换的时候，50 如果再次被交换后（假如此时值不是 20 而是 100，那么则需要交换 50 和 100），会不会破坏左边已经排列好的结构。这里就需要定义我们的交换策略。</p>
<p>对于每组 3 个元素，可能会有以下情况并分别进行处理：</p>
<ul>
<li>最左端为最小值：那么将最左端与中间进行交换，这样最左端相当于值变大了。而对于前一个元素组，其作为最右端的值，变大并不会影响现有结构</li>
<li>中间的为最小值：不需要任何操作</li>
<li>最右端为最小值：将最右端与中间进行交换，最左端未进行变更</li>
</ul>
<p>可以看到，基于以上逻辑，重合元素再第二次参与比较时，要么不变，要么变大，均不会影响原有结构。所以基于这种策略，逐渐遍历数组即可。</p>
<p>最后再来看一下临界情况。</p>
<ul>
<li>如果数组长度为奇数，则正好可以完全分组</li>
<li>如果数组长度为偶数，则最后会有一个元素未参与比较。再看回上面那张图，在已经排列好 30-10-50-20-70-30-80 的情况下
<ul>
<li>假设最后的值为 15（即小于等于倒数第二位的值），则无需处理</li>
<li>假设最后的值为 90（即大于倒数第二位的值），则直接进行交换。由于倒数第二位的元素为上一分组最右端元素，此种交换情况会将其变大，由于上面的逻辑，所以仍不会破坏原有结构</li>
</ul>
<img src="/2022/03/03/sort-an-array-in-a-waveform/sort-an-array-in-a-waveform-4.png" class="" title="假设最后的值为 90 的情况">
</li>
</ul>
<p>所以整体基于这种步长为 2 的遍历和上述交换逻辑，一次遍历就可以完成要求的波浪排序。</p>
<h4 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i = i + <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            tmp = arr[i - <span class="number">1</span>];</span><br><span class="line">            arr[i - <span class="number">1</span>] = arr[i];</span><br><span class="line">            arr[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            tmp = arr[i + <span class="number">1</span>];</span><br><span class="line">            arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">            arr[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后的边界</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; arr[arr.length - <span class="number">1</span>] &gt; arr[arr.length - <span class="number">2</span>]) &#123;</span><br><span class="line">        tmp = arr[arr.length - <span class="number">2</span>];</span><br><span class="line">        arr[arr.length - <span class="number">2</span>] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2"></a> 复杂度分析</h4>
<p>最后再来看一眼复杂度：</p>
<ul>
<li>时间复杂度：只需遍历一次数组，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：只需临时变量进行元素交换，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>对 “pthread_create” 未定义的引用</title>
    <url>/2017/04/26/undefined-reference-to-pthread_create/</url>
    <content><![CDATA[<p>今天在对 Linux 多线程编程进行学习时，在编译代码时出现了问题。</p>
<p>由于使用了 <code>pthread_create</code>, <code>pthread_join</code> 等函数，在使用 <code>gcc</code> 编译时，出现了 <strong>对 ‘pthread_create’ 未定义的引用</strong> 的错误，在上网查询后，得知 pthread 库不是 Linux 系统默认的库，所以在编译时需要添加 <code>-lpthread</code> 参数来使用 libpthread.a 库进行编译。</p>
<pre><code># gcc -o pthread -lpthread pthread.c
</code></pre>
<p>结果还是失败。再次上网查阅，得知 <code>-lpthread</code> 应该放到最后面，修改后编译通过。</p>
<pre><code># gcc thread.c -o thread.c -lpthread
</code></pre>
<p><strong>参考链接：<a href="http://blog.csdn.net/besfanfei/article/details/7542396">http://blog.csdn.net/besfanfei/article/details/7542396</a></strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>记录未使用的 Jekyll 环境搭建</title>
    <url>/2017/01/26/unused-jekyll-on-ubuntu/</url>
    <content><![CDATA[<p>自从win10出现了 Bash on Ubuntu，自己便喜欢上了它，<s>甚至抛弃了虚拟机</s>（双系统还是存在的）。正好最近厌烦了 wp，毕竟太臃肿了，对于我这种没事闲的只会随便写写的没太大用处。</p>
<p>然后就想起了自己沉睡已久的 github，不是因为 github 的免费且无限流量，主要是喜欢 github 上静态页面的简约，百度了下现在的方式，大多是 Jelly 来搭建的，不喜欢在 windows 上装各种软件的我就这么选择了 Bash on Ubuntu，这也是本文的来源。</p>
<h3 id="前期准备"><a class="markdownIt-Anchor" href="#前期准备"></a> 前期准备</h3>
<ul>
<li><a href="http://jekyll.com.cn/">Jekyll 中文官网</a></li>
<li><a href="http://www.ruby-lang.org/">Ruby官网</a></li>
</ul>
<span id="more"></span>
<h3 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h3>
<p>由于 Ubuntu 的仓库里各软件还是很多的，所以首先选择了 apt 方式安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install ruby</span><br><span class="line">$ gem install jekyll</span><br></pre></td></tr></table></figure>
<p>结果出错，ruby 版本太低，输入 ruby -v 查询后是1.95的版本，需求是2点多版本。</p>
<h3 id="换用源码编译安装"><a class="markdownIt-Anchor" href="#换用源码编译安装"></a> 换用源码编译安装</h3>
<p>Linux 下安装软件，至少是我自己的通常思维是先用自带的包管理器安装，如果没有对应的软件包或者版本太低或有缺陷，通常会到官网选择编译安装。</p>
<ul>
<li>首先安装编译环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install build-essential cmake</span><br></pre></td></tr></table></figure>
<ul>
<li>然后下载源码编译安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.0.tar.gz</span><br><span class="line">$ tar -zxvf ruby-2.4.0.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> ruby-2.4.0</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>
<p>在修改 gem 源时出现错误，使用的是国内的 https 源，提示 openssl 有问题。然而系统是安有 openssl 的，而且编译的时候并没有看到有关 openssl 的配置（也有可能是我没有仔细看）。提示可以使用 http 的方式添加源，不过略微强迫症，于是宣告源码编译安装失败。</p>
<h3 id="rvm-方式安装"><a class="markdownIt-Anchor" href="#rvm-方式安装"></a> rvm 方式安装</h3>
<p>这也是在网上查到的第三种也是常见的最后一种安装方式，首先安装 rvm 然后用 rvm 安装 ruby。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -L https://get.rvm.io | bash -s stable</span><br><span class="line">$ <span class="built_in">source</span> ~/.rvm/scripts/rvm</span><br><span class="line">$ rvm requirements</span><br><span class="line">$ rvm install ruby</span><br><span class="line">$ gem install jekyll</span><br></pre></td></tr></table></figure>
<p>成功安装，安装的 ruby 版本为2.3.3。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Ruby</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title>Trino 介绍及部署使用</title>
    <url>/2022/03/15/trino-deploy-tutorials/</url>
    <content><![CDATA[<p>之前我们提到项目上有一个跨库进行 MySQL join 操作的需求，当时选择使用了 MySQL 的 FEDERATED 存储引擎来解决这个问题，具体可以看 <a href="/2022/02/28/mysql-federated-storage-engine-tutorials/">MySQL FEDERATED 存储引擎介绍及使用</a>。但是 FEDERATED 本身只支持 MySQL 数据库，如果我们需要对多个不同种类的数据库进行关联操作，那么还是要依赖第三方组件来进行，比如这次要介绍的 Trino。</p>
<p>Trino 是基于 Java 开发的高性能的、分布式的大数据 SQL 查询引擎，支持基本上所有的常见数据源以及你所想象不到的中间件存储比如 Kafka，同时也支持在单个查询中使用多个数据源来进行关联查询。</p>
<p>官网：<a href="https://trino.io/">Trino</a></p>
<span id="more"></span>
<h3 id="前世今生"><a class="markdownIt-Anchor" href="#前世今生"></a> 前世今生</h3>
<p>Trino 的前身是 Facebook 的 Presto。2012 年， Martin Traverso、Dain Sundstrom 和 David Phillips 入职了 Facebook 的大数据基建部门，并和 Eric Hwang 一同开发了 Presto 来解决 Facebook 的海量 Hadoop 数据仓库的低延迟交互分析的问题，随后在 2013 年 11 月将 Presto 开源。但好景不长，在 2018 年 Facebook 的管理层想要对 Presto 项目及其未来拥有更多的控制，并让毫无 Presto 经验的开发者可以直接提交代码，而且这个决定是在没有 Presto 社区参与的情况下做出的。创始人们觉得这和拥有一个健康开放的社区相矛盾，所以为了使 Presto 的成长更加健康，他们决定离开了 Facebook。</p>
<p>2019 年 1 月，Presto 软件基金会成立了，创始人们决定在未来的 10 个月中不再受雇于任何企业来专门与全球的用户和开发者们接触以及和贡献者合作来扩大和加强社区。随着参与的人员越来越多，Presto 项目也比以前更拥有活力，这个分支叫做 PrestoSQL。</p>
<img src="/2022/03/15/trino-deploy-tutorials/trino-deploy-tutorials-0.png" class="" title="commit 比较">
<p>在 PrestoSQL 稳固几个月之后，Facebook 决定通过 Linux 基金会来创建一个具有竞争关系的社区，第一部就是为 Presto 申请了商标。2019 年 9 月，Facebook 在 Linux 基金会成立了 Presto 基金会，这边的分支叫做 PrestoDB。所以 PrestoSQL 不得不改名，最后将名称改为了 Trino。</p>
<p>最后引用官宣改名文章的最后一句话：<strong>If you love this project, you already love Trino.</strong> ❤️</p>
<h3 id="server-节点安装"><a class="markdownIt-Anchor" href="#server-节点安装"></a> server 节点安装</h3>
<p>因为现阶段只是简单地进行试用，所以我们只安装 server 节点，而且 server 节点同时也可以作为 worker 节点使用。</p>
<h4 id="java-环境"><a class="markdownIt-Anchor" href="#java-环境"></a> Java 环境</h4>
<p>为什么要单独强调 Java 环境，是因为 Trino 对 Java 环境很挑剔，官网文档要求 64 位的 Java 11 运行环境，且最低版本号为 11.0.11。如果是 Java 12 或者 13、17 等后续版本，官方说可能正常工作，并没有做过测试。同时推荐 <a href="https://www.azul.com/downloads/?package=jdk#download-openjdk">Azul Zulu</a> 的 JDK，官方说只针对 Azul Zulu 的发行版做了测试，可以说是很娇贵了。</p>
<p>所以为了避免因为 JDK 的问题使程序出现问题，我们还是老老实实按照要求使用 Azul Zulu 的 Open JDK，具体安装过程不再赘述，是用的版本为当前 Java 11 的最新版 11.0.14.1+1。</p>
<img src="/2022/03/15/trino-deploy-tutorials/trino-deploy-tutorials-1.png" class="" title="JDK 版本">
<h4 id="python-环境"><a class="markdownIt-Anchor" href="#python-环境"></a> Python 环境</h4>
<p>Python 环境的要求相对来说就很宽泛了，官方说 2.6.x、2.7.x、或者 3.x 的版本均可，因为 Python 环境只是给启动脚本使用的，并不会影响程序的正常运行。都 2022 年了，所以我们这里使用 Python 3 的最新版即可。</p>
<img src="/2022/03/15/trino-deploy-tutorials/trino-deploy-tutorials-2.png" class="" title="Python 版本">
<h4 id="安装-trino"><a class="markdownIt-Anchor" href="#安装-trino"></a> 安装 Trino</h4>
<p>从官网下载 server 节点压缩包并解压即可。Trino 需要一个目录来存储日志等数据，官方建议放在 Trino 安装目录外，因为这样可以很方便地在后续升级 Trino 版本，具体配置放下面再说。</p>
<h3 id="trino-配置"><a class="markdownIt-Anchor" href="#trino-配置"></a> Trino 配置</h3>
<p>安装完 Trino 之后还需要对 Trino 进行一连串的配置才可以运行。首先在安装目录创建 <code>etc</code> 文件夹，用来放置配置信息，然后通过创建对应文件的方式对 Trino 进行配置。</p>
<h4 id="node-节点配置文件"><a class="markdownIt-Anchor" href="#node-节点配置文件"></a> Node 节点配置文件</h4>
<p>创建 <code>node.properties</code> 文件配置节点信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 集群的环境名称，同一集群下的节点必须具有相同的环境名</span><br><span class="line">node.environment=test</span><br><span class="line"># 节点的唯一 ID，集群内不能重复</span><br><span class="line">node.id=b0e4c61a-a304-47d3-bfc7-88be4c6a22c1</span><br><span class="line"># 数据存储路径</span><br><span class="line">node.data-dir=/opt/trino-server-374/data</span><br></pre></td></tr></table></figure>
<h4 id="jvm-配置"><a class="markdownIt-Anchor" href="#jvm-配置"></a> JVM 配置</h4>
<p>创建 <code>jvm.config</code> 文件存储 JVM 启动参数，在官方样例中删掉了 OOM 相关的参数并调整了下内存需求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-server</span><br><span class="line">-Xmx4G</span><br><span class="line">-XX:-UseBiasedLocking</span><br><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:G1HeapRegionSize=32M</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-XX:ReservedCodeCacheSize=512M</span><br><span class="line">-XX:PerMethodRecompilationCutoff=10000</span><br><span class="line">-XX:PerBytecodeRecompilationCutoff=10000</span><br><span class="line">-Djdk.attach.allowAttachSelf=true</span><br><span class="line">-Djdk.nio.maxCachedBufferSize=2000000</span><br></pre></td></tr></table></figure>
<h4 id="config-配置文件"><a class="markdownIt-Anchor" href="#config-配置文件"></a> Config 配置文件</h4>
<p>创建 <code>config.properties</code> 文件，储存的是一些杂七杂八的配置。因为我们只有一个节点做测试，即当 server 又当 worker，所以使用下列配置，端口按需调整：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 标识为协调员，可以接受客户端请求并管理查询</span><br><span class="line">coordinator=true</span><br><span class="line"># 作为协调员的同时可作为 worker 节点使用</span><br><span class="line">node-scheduler.include-coordinator=true</span><br><span class="line">http-server.http.port=8080</span><br><span class="line">query.max-memory=2GB</span><br><span class="line">query.max-memory-per-node=2GB</span><br><span class="line"># 协调员的地址，注册发现使用</span><br><span class="line">discovery.uri=http://127.0.0.1:8080</span><br></pre></td></tr></table></figure>
<h4 id="日志等级"><a class="markdownIt-Anchor" href="#日志等级"></a> 日志等级</h4>
<p>创建 <code>log.properties</code> 文件调整日志等级，可选，默认为 <code>INFO</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.trino=INFO</span><br></pre></td></tr></table></figure>
<h4 id="数据源配置"><a class="markdownIt-Anchor" href="#数据源配置"></a> 数据源配置</h4>
<p>Trino 支持的数据源非常的多，具体可以看官方文档 <a href="https://trino.io/docs/current/connector.html">Connectors</a>，这里我们只配置一个 MySQL 和一个 PostgreSQL 作为测试。</p>
<p>首先创建 <code>catalog</code> 文件夹，然后创建 <code>mysql.properties</code> 文件，文件名的 <code>mysql</code> 前缀为 catalog 名称，可以自由指定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定为 MySQL</span><br><span class="line">connector.name=mysql</span><br><span class="line"># JDBC 连接地址，注意，MySQL 作为数据源时不能指定具体 database</span><br><span class="line">connection-url=jdbc:mysql://192.168.1.202:3306?useSSL=false</span><br><span class="line">connection-user=root</span><br><span class="line">connection-password=root</span><br></pre></td></tr></table></figure>
<p>然后再创建 <code>postgresql.properties</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connector.name=postgresql</span><br><span class="line">connection-url=jdbc:postgresql://192.168.1.202:5432/test</span><br><span class="line">connection-user=postgres</span><br><span class="line">connection-password=postgres</span><br></pre></td></tr></table></figure>
<h4 id="启动-trino"><a class="markdownIt-Anchor" href="#启动-trino"></a> 启动 Trino</h4>
<p>可以通过运行 <code>bin</code> 目录下的 <code>launcher</code> 文件启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台运行</span></span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374/bin$ ./launcher start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前台运行</span></span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374/bin$ ./launcher run</span><br></pre></td></tr></table></figure>
<p>看到显示 <code>SERVER STARTED</code> 后就说明 Trino 正常启动了，可以通过浏览器直接访问 HTTP 端口来查看集群状态，用户名随意输入：</p>
<img src="/2022/03/15/trino-deploy-tutorials/trino-deploy-tutorials-3.png" class="" title="web ui">
<h3 id="trino-使用"><a class="markdownIt-Anchor" href="#trino-使用"></a> Trino 使用</h3>
<p>我们可以通过两种方式来使用 Trino，使用官方的 CLI 命令工具，或者通过 JDBC 驱动在 Java 程序中使用。</p>
<h4 id="cli-工具"><a class="markdownIt-Anchor" href="#cli-工具"></a> CLI 工具</h4>
<p>CLI 工具需要 Java 8 或更高版本作为运行环境，我们只需要下载官方提供的 jar 包即可直接使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374$ wget https://repo1.maven.org/maven2/io/trino/trino-cli/374/trino-cli-374-executable.jar</span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374$ chmod +x trino-cli-374-executable.jar</span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374$ ./trino-cli-374-executable.jar --server localhost:8080 --execute &#x27;SHOW TABLES FROM mysql.test&#x27;</span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374$ ./trino-cli-374-executable.jar --server localhost:8080 --execute &#x27;SELECT * FROM mysql.test.user&#x27;</span><br></pre></td></tr></table></figure>
<p>其中，<code>mysql</code> 指的是我们在 catlog 文件夹创建的文件名，<code>test</code> 为我们 MySQL 的数据库名称，<code>user</code> 为表名。</p>
<h4 id="jdbc-驱动"><a class="markdownIt-Anchor" href="#jdbc-驱动"></a> JDBC 驱动</h4>
<p>CLI 工具的泛用性不强，真要产品化使用还是得采用 JDBC 方式。首先按照官方，添加 JDBC 驱动：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.trino<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>trino-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>374<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后配置 JDBC 连接地址。这里可以有多种方案来配置，其中 <code>catalog</code> 为文件名，<code>schema</code> 相当于 MySQL 的 database：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:trino://host:port</span><br><span class="line">jdbc:trino://host:port/catalog</span><br><span class="line">jdbc:trino://host:port/catalog/schema</span><br></pre></td></tr></table></figure>
<p>用户名可以任意输入，然后就可以正常使用了。</p>
<h3 id="高级配置"><a class="markdownIt-Anchor" href="#高级配置"></a> 高级配置</h3>
<p>上面的流程是可以正常使用的，但是细节上处理的都不到位，比如默认是匿名访问的，用户名可以任意输入；默认没有权限控制，可以访问所有的 catalog 等等，所以我们需要进行一下高级配置。</p>
<h4 id="配置认证方式"><a class="markdownIt-Anchor" href="#配置认证方式"></a> 配置认证方式</h4>
<p>Trino 支持很多种的认证方式，基本上常见的都支持。为了减少应用配置复杂度，我们仍然选择通用的用户名/密码方式进行认证。</p>
<p>首先打开我们的 <code>config.properties</code> 文件，添加认证配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http-server.authentication.type=PASSWORD</span><br></pre></td></tr></table></figure>
<p>然后仍然是在 <code>etc</code> 目录下创建 <code>password-authenticator.properties</code> 文件，指定密码来源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 采用文件的方式</span><br><span class="line">password-authenticator.name=file</span><br><span class="line">指定密码文件位置</span><br><span class="line">file.password-file=/opt/trino-server-374/etc/password.db</span><br></pre></td></tr></table></figure>
<p>然后创建密码文件，我们可以使用 <a href="https://httpd.apache.org/">Apache HTTP Server</a> 的 <a href="https://httpd.apache.org/docs/current/programs/htpasswd.html">htpasswd</a> 工具来生成密码文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch password.db</span><br><span class="line">htpasswd -B -C 10 password.db user</span><br></pre></td></tr></table></figure>
<p><code>user</code> 为我们想要创建的用户名，然后输入密码即可。</p>
<h4 id="开启-tls-支持"><a class="markdownIt-Anchor" href="#开启-tls-支持"></a> 开启 TLS 支持</h4>
<p>当采用用户名/密码的方式进行认证时，Trino 强制要求我们使用 TLS，所以我们需要对其进行配置。</p>
<p>首先我们需要创建 HTTPS 证书，由于是本地测试，所以我们直接自己签发一个。Trino 支持 PEM 文件和 JKS 文件，我们使用标准的 PEM 文件进行配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成私钥</span></span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374/etc/ssl$ openssl genrsa -out server.key 2048</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成 CSR</span> </span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374/etc/ssl$ openssl req -new -key server.key -out server.csr</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己派发证书</span></span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374/etc/ssl$ openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成 PEM 格式文件</span></span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374/etc/ssl$ cat server.key server.crt &gt; server.pem</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验 PEM 文件</span></span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374/etc/ssl$ openssl rsa -in server.pem -check -noout</span><br><span class="line">ubuntu@CRUCIAL:/opt/trino-server-374/etc/ssl$ openssl x509 -in server.pem -text -noout</span><br></pre></td></tr></table></figure>
<p>生成完证书后，在 <code>config.properties</code> 文件中添加如下配置即可开启 TLS 支持：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启 https</span><br><span class="line">http-server.https.enabled=true</span><br><span class="line"># 指定 https 端口</span><br><span class="line">http-server.https.port=8443</span><br><span class="line"># 指定证书文件</span><br><span class="line">http-server.https.keystore.path=/opt/trino-server-374/etc/ssl/server.pem</span><br></pre></td></tr></table></figure>
<p>最后修改 JDBC 连接地址，由于是自签证书，所以我们需要关闭证书校验：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:trino://127.0.0.1:8443?SSL=true&amp;SSLVerification=NONE</span><br></pre></td></tr></table></figure>
<p>同理，CLI 命令修改为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./trino-cli-374-executable.jar --server https://localhost:8443 --user user --password --execute &#x27;SELECT * FROM mysql.test.user&#x27; --insecure</span><br></pre></td></tr></table></figure>
<h4 id="权限控制"><a class="markdownIt-Anchor" href="#权限控制"></a> 权限控制</h4>
<p>默认在不开启权限控制的情况下，用户都拥有最大权限，这显示是很不安全的，所以需要配置权限控制。</p>
<p>创建 <code>access-control.properties</code> 文件，指定权限控制文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access-control.name=file</span><br><span class="line"># 指定控制文件位置</span><br><span class="line">security.config-file=/opt/trino-server-374/etc/rules.json</span><br><span class="line"># 自动刷新间隔，不再需要重启 Trino 即可自动生效</span><br><span class="line">security.refresh-period=1s</span><br></pre></td></tr></table></figure>
<p>创建 <code>group-provider.properties</code> 文件，指定群组配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">group-provider.name=file</span><br><span class="line">file.group-file=/opt/trino-server-374/etc/group.txt</span><br></pre></td></tr></table></figure>
<p>然后编辑群组映射关系 <code>group.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin:admin-user</span><br></pre></td></tr></table></figure>
<p>然后创建 <code>rules.json</code> 文件编写规则，具体的权限控制比较复杂，可以参考 <a href="https://trino.io/docs/current/security/file-system-access-control.html">File-based access control</a>，这里我们只写一个基础的权限控制规则，实现 <code>admin</code> 组的用户可以进行所有操作，任意用户可以访问 <code>mysql</code>，user 可以读取 <code>postgresql</code> 的数据，<code>system</code> 没有用户可以访问。权限匹配是从上到下的，如果没有匹配到，则默认拒绝权限。具体配置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;catalogs&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;allow&quot;</span><span class="punctuation">:</span><span class="string">&quot;all&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;catalog&quot;</span><span class="punctuation">:</span><span class="string">&quot;mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;allow&quot;</span><span class="punctuation">:</span><span class="string">&quot;all&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span><span class="string">&quot;user&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;catalog&quot;</span><span class="punctuation">:</span><span class="string">&quot;postgresql&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;allow&quot;</span><span class="punctuation">:</span><span class="string">&quot;read-only&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;catalog&quot;</span><span class="punctuation">:</span><span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;allow&quot;</span><span class="punctuation">:</span><span class="string">&quot;none&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>再创建用户 user2 及 admin-user，来测试一下效果：</p>
<p><strong>这是开启权限控制之前 user 可以看到的</strong></p>
<img src="/2022/03/15/trino-deploy-tutorials/trino-deploy-tutorials-4.png" class="" title="开启权限控制之前 user 可见范围">
<p><strong>这是开启权限控制之后 user 可以看到的</strong></p>
<img src="/2022/03/15/trino-deploy-tutorials/trino-deploy-tutorials-5.png" class="" title="开启权限控制之后 user 可见范围">
<p><strong>这是 user2 可以看到的</strong></p>
<img src="/2022/03/15/trino-deploy-tutorials/trino-deploy-tutorials-6.png" class="" title="user2 可见范围">
<p><strong>最后这是 admin-user 可以看到的</strong></p>
<img src="/2022/03/15/trino-deploy-tutorials/trino-deploy-tutorials-7.png" class="" title="admin-user 可见范围">
]]></content>
      <categories>
        <category>Trino</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Chromebook 中配置 Linux 子系统的中文环境并安装中文输入法</title>
    <url>/2022/05/15/use-zh-cn-locale-in-linux-on-chromebook/</url>
    <content><![CDATA[<p>虽然现在 Chrome 的版本号已经刷到了 101（目前个人在使用 103 的开发者版本），但是在 Chromebook 中仍然没有原生支持在其 Linux 子系统中输入除了英文之外的其他语言。所以如果想要在 Linux 及其 GUI 程序中输入中文，则需要自己安装中文输入法并配置相关环境。</p>
<p>fydeOS 作为本地化的 Chrome OS，官方编写了在 Linux 子系统中安装中文输入法的文章，但是步骤并不完整，导致半路无法进行，且使用了 deprecated 的文件配置环境变量，存在某个版本被删除导致出错的风险，所以重新整理下完整步骤。</p>
<span id="more"></span>
<h3 id="一-配置中文环境"><a class="markdownIt-Anchor" href="#一-配置中文环境"></a> 一、配置中文环境</h3>
<p>首先安装中文字体，此处以文泉驿微米黑和文泉驿正黑字体为例。当然，你也可以选择任意其他中文字体。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install fonts-wqy-microhei fonts-wqy-zenhei</span><br></pre></td></tr></table></figure>
<p>然后配置系统默认语言，选择 <code>zh_CN.UTF-8</code> 编码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure>
<p>至此，Linux 子系统中就可以正常显示中文了。</p>
<h3 id="二-安装中文输入法"><a class="markdownIt-Anchor" href="#二-安装中文输入法"></a> 二、安装中文输入法</h3>
<p>仅仅在 Linux 子系统中显示中文是不够的，由于不能使用系统输入法，所以如果想要在 Linux 子系统中输入中文，那么还需要安装中文输入法。</p>
<h4 id="1-安装-fcitx-输入法"><a class="markdownIt-Anchor" href="#1-安装-fcitx-输入法"></a> 1. 安装 Fcitx 输入法</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install fcitx fcitx-lib*</span><br></pre></td></tr></table></figure>
<p>由于不太喜欢自带的中文输入法，所以额外安装谷歌拼音输入法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install fcitx-googlepinyin</span><br></pre></td></tr></table></figure>
<h4 id="2-配置默认输入方式"><a class="markdownIt-Anchor" href="#2-配置默认输入方式"></a> 2. 配置默认输入方式</h4>
<p>安装 Fcitx 输入法后，配置系统默认输入方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">im-config</span><br></pre></td></tr></table></figure>
<p>按顺序点击确定 -&gt; Yes -&gt; 选择 fcitx -&gt; 确定 -&gt; 确定。</p>
<h4 id="3-配置-fcitx-输入法"><a class="markdownIt-Anchor" href="#3-配置-fcitx-输入法"></a> 3. 配置 Fcitx 输入法</h4>
<p>执行下列命令打开 Fcitx 配置窗口，点击左下角的 <code>+</code> 选择谷歌拼音输入法，并按需调整。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fcitx &amp;&amp; fcitx-configtool</span><br></pre></td></tr></table></figure>
<h4 id="4-配置-fcitx-开机自启动"><a class="markdownIt-Anchor" href="#4-配置-fcitx-开机自启动"></a> 4. 配置 Fcitx 开机自启动</h4>
<p>添加 <code>/usr/bin/fcitx-autostart</code> 到开机自启文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi ~/.sommelierrc</span><br></pre></td></tr></table></figure>
<h4 id="5-配置语言输入环境"><a class="markdownIt-Anchor" href="#5-配置语言输入环境"></a> 5. 配置语言输入环境</h4>
<p>现有的文档都是修改 <code>/etc/systemd/user/cros-garcon.service.d/cros-garcon-override.conf</code> 文件来配置环境变量，但是这个文件现在已经被 deprecated 了，所以我们可以按照提示打开 <a href="https://chromium.googlesource.com/chromiumos/docs/+/main/containers_and_vms.md#Can-I-set-environment-variables-for-my-container">Can I set environment variables for my container</a> 来使用最新的配置环境变量的方法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.config/environment.d/</span><br><span class="line">vi ~/.config/environment.d/fcitx.conf</span><br></pre></td></tr></table></figure>
<p>在里面填入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>
<h4 id="6-安装字体管理器可选"><a class="markdownIt-Anchor" href="#6-安装字体管理器可选"></a> 6. 安装字体管理器（可选）</h4>
<p>最后可以按照需要安装字体管理器，导入 <code>.ttf</code> 或 <code>.otf</code> 字体。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install font-manager</span><br></pre></td></tr></table></figure>
<h3 id="三-参考文档"><a class="markdownIt-Anchor" href="#三-参考文档"></a> 三、参考文档</h3>
<ul>
<li><a href="https://fydeos.com/help/knowledge-base/linux-subsystem/chinese-ime-in-linux-subsystem">在 Linux 子系统中安装中文输入法</a></li>
<li><a href="https://www.reddit.com/r/chromeos/comments/oqlgwl/tutorial_how_to_use_non_english_input_methods_on/">[Tutorial] How to use non english input methods on Linux(beta) a.k.a Crostini.(Like pinyin keyboard)</a></li>
</ul>
]]></content>
      <categories>
        <category>Chromebook</category>
      </categories>
      <tags>
        <tag>Chromebook</tag>
        <tag>Chrome OS</tag>
        <tag>Crostini</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 配置</title>
    <url>/2017/04/04/windows-init/</url>
    <content><![CDATA[<blockquote>
<p>一个存放 Windows 各种配置和各种命令的地方，毕竟 Windows 的功能有的藏的实在是深或者是没有直接的入口。这种东西大多网络收集，且都是网上存在的，找不到具体出处，所以此处不列出出处。</p>
</blockquote>
<h3 id="注册表相关"><a class="markdownIt-Anchor" href="#注册表相关"></a> 注册表相关</h3>
<p>“regedit.exe” 是 Windows 系统的注册表编辑器，是 Registry Editor 的缩写。其实质上是一个庞大的数据库，它存储这下面这些内容：软、硬件的有关配置和状态信息，应用程序和资源管理器外壳的初始条件、首选项和卸载数据；计算机的整个系统的设置和各种许可，文件扩展名与应用程序的关联，硬件的描述、状态和属性；计算机性能纪录和底层的系统状态信息，以及各类其他数据。（摘自百度百科）</p>
<p>通常可使用 <code>win + r</code> 运行输入 <code>regedit</code> 打开。</p>
<span id="more"></span>
<h4 id="删除我的电脑中应用添加的图标"><a class="markdownIt-Anchor" href="#删除我的电脑中应用添加的图标"></a> 删除我的电脑中应用添加的图标</h4>
<p>由于一般使用绿色版，所以接触的不是很多，但印象中百度云管家、360 云盘这种东西都是会增加图标的，而且有的应用添加的图标是不能右键删除的，这里记录下使用注册表的解决方法。</p>
<p>接触到的图标都是在下列位置新建<strong>注册表项</strong>，发现其余的再补充。</p>
<pre><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace
</code></pre>
<p>其中一个项对应一个图标，但没有很好的办法辨别其对应关系，在图标很多时建议先备份再删除。</p>
<p>日常电脑中没有那种烦人的图标，这次因为有一个出现才去找解决办法删掉了，所以，已经没有图可以截了。</p>
<h4 id="win10-系统图片打开方式恢复默认照片查看器"><a class="markdownIt-Anchor" href="#win10-系统图片打开方式恢复默认照片查看器"></a> Win10 系统图片打开方式恢复默认照片查看器</h4>
<pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Photo Viewer\Capabilities\FileAssociations
</code></pre>
<p>其中每一个<strong>字符串值</strong>代表一种后缀的关联，数值名称为所想要关联的后缀，例如 <code>.jpg</code>，数值数据统一写 <code>PhotoViewer.FileAssoc.Tiff</code>，想恢复哪种右键关联就新建对应后缀的注册表<strong>字符串值</strong>即可。</p>
<p><strong>已知此路径非唯一的恢复方式，存在其余注册表路径可以恢复。</strong></p>
<p>不过，还是推荐使用 <a href="http://www.chuyu.me/zh-Hans/index.html">Dism++</a> 恢复，方便快捷（Dism++ 采用的就是上面所列出的的注册表路径）。</p>
<h3 id="powershell"><a class="markdownIt-Anchor" href="#powershell"></a> PowerShell</h3>
<h4 id="卸载modern-应用"><a class="markdownIt-Anchor" href="#卸载modern-应用"></a> 卸载Modern 应用</h4>
<p>除了企业的 LTSB 长期支持版本，家庭版和专业版都会附带 Modern 应用，对于很少使用且不能直接卸载的，可以使用 PowerShell 来卸载部分应用。<br />
仅列出无法右键卸载的，可用 PowerShell 卸载的部分应用。<br />
闹钟：get-appxpackage <em>Microsoft.WindowsAlarms</em> | remove-appxpackage<br />
人脉：get-appxpackage <em>Microsoft.People</em> | remove-appxpackage<br />
信息：get-appxpackage <em>Microsoft.Messaging</em> | remove-appxpackage<br />
StickyNote：get-appxpackage <em>Sticky</em> | remove-appxpackage</p>
<h3 id="杂类"><a class="markdownIt-Anchor" href="#杂类"></a> 杂类</h3>
<h4 id="关闭密码登录"><a class="markdownIt-Anchor" href="#关闭密码登录"></a> 关闭密码登录</h4>
<p>由于各种原因，Windows 账户需要设置密码然而很烦每次开机都要输入密码，使用下面设置即可完成不需每次都输入密码即可自动登录系统。</p>
<p>开始——运行——输入 <code>control userpasswords2</code>，取消 “要使用本计算机，用户必须输入用户名和密码” 勾选，点击确定关闭窗口后输入想自动登录的用户名和密码，确定后即可。</p>
<h4 id="桌面图标设置"><a class="markdownIt-Anchor" href="#桌面图标设置"></a> 桌面图标设置</h4>
<p>通常系统自带桌面图标的设置，可以在进入系统桌面后，右键个性化找到桌面图标设置选项（具体因系统而异）进行修改，然而对于服务器系统，右键并没有个性化选项，无法修改桌面图标，可使用下列命令调出设置窗口设置。</p>
<p>开始——运行</p>
<pre><code>rundll32.exe shell32.dll,Control_RunDLL desk.cpl,,0
</code></pre>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Regedit</tag>
        <tag>PowerShell</tag>
      </tags>
  </entry>
</search>
